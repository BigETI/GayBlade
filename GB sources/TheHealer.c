/****************************************                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /***********************************        DragonBlade   Ver 1.0.0      ****      © Copyright by Ryan Best 1992  ****          All Rights Reserved.       *******************************************/#include "GB.h"extern	WindowPtr	gPictureWindow, gGameWindow, gCastleWindow;extern	Boolean		gDone, gWNEImplemented;extern	EventRecord	gTheEvent;extern	MenuHandle	gAppleMenu,gFileMenu,gOptionsMenu,gSpecialMenu;extern	Rect		gIntroRect, gTavernRect, gBankRect, gRollerRect, gStoreRect, gCharRect0,					gCharRect1, gCharRect2, gCharRect3,gItemsRect, gMapRect, gSpellsRect,gSrcRect,					gGuildRect,gHealerRect,gdungeonRect, gStatsRect, gPartyInfoRect,					gUseRect,gPanicRect, gMoveRect, gDungDispRect, gActionRect,gConsoleRect, 					gMScreenRect,leftRect,centerRect,rightRect,cLeftRect,cCenterRect,cRightRect,					doorRect,clwallRect,crwallRect,cRect, gChestRect,gItemRect,gListStatsRect,					gListItemsRect, gCompassRect,gTreasureRect;extern	PicHandle	gThePicture, gConsolePicture, gDungeon1, gLeftWall, gCenterWall, gRightWall,					gLeftDoor,gRightDoor,gFlatWall,gFlatDoor,gOpenSpace,gFarWall,gFarDoor,gCLWall,gCRWall,					gCOpenSpace,gCLDoor,gCRDoor,gCFWall,gCFDoor, gMScreenPicture;extern	CIconHandle	gVialIcon,gShieldIcon, gRingIcon, gSphereIcon,gFlailIcon,gCloakIcon,gArrowIcon,gDaggerIcon,					gSwordIcon,gHelmetIcon,gTorchIcon,gBookIcon,gGlovesIcon,gBurnedIcon,gArmorIcon,					gChestIcon, gCompassIcon,gCNorthIcon,gCSouthIcon,gCEastIcon,					gCWestIcon;extern int			gSndOn,gPanicOn, gInCastle, gPartyNum,gNewChar, gSndNum, gLastChar, gLight,					gLightSpell,gItemUseScreen, gCurChar, gInPrison,gDialogNum,gDisplay,gDungLevel,gXLoc,gYLoc,					gView,gResistFire,gResistIce,gPartyInvis,gInEncounter,gCureWho,gFoundItems[3],					gCreatType, gCreatureCounter, gCreatHits[10],gLevelCount,dmgType,gTreasure,					gDisarmSpellCast,gCompass,ASave,gMagicItems[4],gSpeed,gCharShields[4],gEvade;extern	long		gStats[6], gDungParty[4],gWhichChar,glastWhen,gPanic;extern	Point		glastWhere;extern	DialogPtr	gCastleDialog;extern	RGBColor	gNameBack, gStatsBack, gSpecName,gNormName,gMessBack,gBlack,gStatsFore;extern	CCrsrHandle	gSpellCursor;extern	SFReply		fileName;extern	struct	CharInfo {	Str255	name;	int		type;	int		race;	int		level;	int		exp;	int		status;	int		hits;	int		dmg;	int		age;	int		str;	int		wis;	int		itl;	int		con;	int		dex;	int		items[7];		int		itemsInUse[7];			/* what items are being used */	int		gold;	int	 	bank;					/* released wizard? */	int		mspells[4],cspells[4];	int		dngLevel, xLoc, yLoc,Pos;	};extern	struct	CharInfo	GameChars[8];						/*  Can store up to 8 chars per game  */extern	struct	ItemInfo {	Str255			name;	unsigned char	type;	unsigned char	status;		/* whether item is in use or not */	unsigned char	instore;	unsigned char	level;	Byte			attrib;	unsigned char	dmg;	unsigned char	def;	unsigned char	con;};extern	struct	ItemInfo	GameItems[101];extern	struct	DungInfo 				{	unsigned int	XY[10][10];		/*  x, y  rooms location */	unsigned int	N[100];			/* 100 rooms w/north walls */	unsigned int	S[100];			/* 100 rooms w/south walls */	unsigned int	E[100];			/* 100 rooms w/east walls */	unsigned int	W[100];			/* 100 rooms w/west walls */	unsigned int	SA[100];};extern	struct	DungInfo	Dungeon[1];	extern struct	CreatureInfo 				/* access database each encounter */{	Str255			name;	unsigned char	type;	unsigned char	status;		/* For use in editor only */	unsigned char	instore;	/* Unused variable */	unsigned char	level;	Byte			attrib;	Byte			dmg;	Byte			def;	Byte			hits;};extern struct	CreatureInfo	GameCreatures[1];/************************ TheHealer ****************************/TheHealer(){int				itemType, healer_id, userAction, itemHit, cost,x,yy, dialogDone = FALSE; Handle			itemHandle;Rect			itemRect;Str255			theText,lmess, zztext;gSndNum=19402;PlaySound();if (gDungParty[0]==99)		/* no char, then go away! */{	ClearMessage();		DrawString("\pThe Healer is out. Come back later.");	return;}			ClearMessage();			DrawString(GameChars[gCurChar].name);DrawString("\p has entered the healer.");	RGBBackColor(&gStatsBack);			gDialogNum=409;DoDialog();	GetDItem(gCastleDialog, 1, &itemType, &itemHandle, &itemRect);	HiliteControl(itemHandle, 255);					/** PAY **/																/*** normal, so grey everything out ***/if (GameChars[gCurChar].dmg==0 && GameChars[gCurChar].status>=2)	{				ParamText(GameChars[gCurChar].name,"\pNormal","\p0","\p");			GetDItem(gCastleDialog, 7, &itemType, &itemHandle, &itemRect);		HiliteControl(itemHandle, 255);			/* grey out CURE HITS */			GetDItem(gCastleDialog, 8, &itemType, &itemHandle, &itemRect);		HiliteControl(itemHandle, 255);			/* grey out  POSION */				GetDItem(gCastleDialog, 9, &itemType, &itemHandle, &itemRect);		HiliteControl(itemHandle, 255);			/* grey out RAISE */			GetDItem(gCastleDialog, 10, &itemType, &itemHandle, &itemRect);		HiliteControl(itemHandle, 255);			/* grey out BURY */						}													/*** wounded ***/else if (GameChars[gCurChar].dmg>0 && GameChars[gCurChar].status>=2)	{		NumToString(GameChars[gCurChar].dmg,theText);			ParamText(GameChars[gCurChar].name,"\pWounded",theText,"\p");			GetDItem(gCastleDialog, 8, &itemType, &itemHandle, &itemRect);		HiliteControl(itemHandle, 255);			/* grey out  POISON */						GetDItem(gCastleDialog, 9, &itemType, &itemHandle, &itemRect);		HiliteControl(itemHandle, 255);			/* grey out RAISE */			GetDItem(gCastleDialog, 10, &itemType, &itemHandle, &itemRect);		HiliteControl(itemHandle, 255);			/* grey out BURY */					}													/*** Dead ***/	else if (GameChars[gCurChar].status==DEAD)	{					ParamText(GameChars[gCurChar].name,"\pDead","\p0","\p");			GetDItem(gCastleDialog, 7, &itemType, &itemHandle, &itemRect);		HiliteControl(itemHandle, 255);			/* grey out CURE HITS */			GetDItem(gCastleDialog, 8, &itemType, &itemHandle, &itemRect);		HiliteControl(itemHandle, 255);			/* grey out  POISON */				}													/*** Perm Dead ***/else if (GameChars[gCurChar].status==PERMDEAD)	{			ParamText(GameChars[gCurChar].name,"\pPermanently Dead","\p0","\p");			GetDItem(gCastleDialog, 7, &itemType, &itemHandle, &itemRect);		HiliteControl(itemHandle, 255);			/* grey out CURE HITS */			GetDItem(gCastleDialog, 8, &itemType, &itemHandle, &itemRect);		HiliteControl(itemHandle, 255);			/* grey out  POSION */				GetDItem(gCastleDialog, 9, &itemType, &itemHandle, &itemRect);		HiliteControl(itemHandle, 255);			/* grey out RAISE */			}if (GameChars[gCurChar].status==POISONED){	NumToString(GameChars[gCurChar].level,theText);	ParamText(GameChars[gCurChar].name,"\pPoisoned",theText,"\p");			GetDItem(gCastleDialog, 8, &itemType, &itemHandle, &itemRect);	HiliteControl(itemHandle, 0);			/* highlight  POSION */	}	while (dialogDone == FALSE)	{		ModalDialog(NIL_POINTER, &itemHit);			switch (itemHit)			{				case CANCEL_ITEM:	/* LEAVE */				 	DisposeDialog(gCastleDialog);	 					dialogDone = TRUE;					break;				case OKAY_ITEM:		/* PAY */					HealerAction(userAction);				 	DisposeDialog(gCastleDialog);	 					dialogDone = TRUE;					DeadChar();			/** sorts party **/										break;				case 7:			/* CURE HITS */					HealerButtonsOff();						/* turn buttons off if on */						GetDItem(gCastleDialog, 7, &itemType, &itemHandle, &itemRect);						SetCtlValue (itemHandle,ON);			/* check it */						GetDItem(gCastleDialog, 1, &itemType, &itemHandle, &itemRect);							HiliteControl(itemHandle, 0);	/** PAY **/							userAction=1;					break;				case 8:			/* CURE POISON */					HealerButtonsOff();						/* turn buttons off if on */						GetDItem(gCastleDialog, 8, &itemType, &itemHandle, &itemRect);						SetCtlValue (itemHandle,ON);			/* check it */						GetDItem(gCastleDialog, 1, &itemType, &itemHandle, &itemRect);							HiliteControl(itemHandle, 0);	/** PAY **/							userAction=2;					break;							case 9:			/* RAISE DEAD */					HealerButtonsOff();						/* turn buttons off if on */						GetDItem(gCastleDialog, 9, &itemType, &itemHandle, &itemRect);						SetCtlValue (itemHandle,ON);			/* check it */						GetDItem(gCastleDialog, 1, &itemType, &itemHandle, &itemRect);							HiliteControl(itemHandle, 0);	/** PAY **/						userAction=3;					break;				case 10:		/* BURY DEAD */					HealerButtonsOff();						/* turn buttons off if on */						GetDItem(gCastleDialog, 10, &itemType, &itemHandle, &itemRect);						SetCtlValue (itemHandle,ON);			/* check it */						GetDItem(gCastleDialog, 1, &itemType, &itemHandle, &itemRect);							HiliteControl(itemHandle, 0);	/** PAY **/						userAction=4;					break;													}	}  SetPort(gGameWindow);}	/******************************* Healer Buttons Off ****************************/HealerButtonsOff()						/* turn buttons off if on */{int				itemType,x,yy, dialogDone = FALSE; Handle			itemHandle;Rect			itemRect;for (x=7;x<=10;x++)	{		GetDItem(gCastleDialog, x, &itemType, &itemHandle, &itemRect);		SetCtlValue (itemHandle,OFF);			/* turn off */	}}/******************************* HealerAction ****************************/HealerAction(userAction)				/* perform appropriate routine */int		userAction;{int		z=FALSE; switch (userAction)	{		case 1:				/* FULL CURE */			if (GameChars[gCurChar].gold>=GameChars[gCurChar].dmg)					{						GameChars[gCurChar].gold=GameChars[gCurChar].gold-							GameChars[gCurChar].dmg;							GameChars[gCurChar].dmg=0;							ClearMessage(); 				 		DrawString("\pYou're all healed, thanks for the donation!");					 z=TRUE;					break; 				 								}			else			/* PARTIAL CURE */				{					while (z!=TRUE)					{					if (GameChars[gCurChar].gold>=1 && GameChars[gCurChar].dmg>=0)						{						  GameChars[gCurChar].gold=GameChars[gCurChar].gold-1;						  GameChars[gCurChar].dmg--;							if (GameChars[gCurChar].gold<=2)								{									ClearMessage();									DrawString("\pYou've run out of gold for healing!");																z=TRUE;									break;								}						}					else						{						ClearMessage();						DrawString("\pWe don't accept charity cases. Out!");						z=TRUE;						break;						}					}				}			break;		case 2:			/* CURE POISON   */			if (GameChars[gCurChar].gold<=GameChars[gCurChar].level)				{					ClearMessage(); 				 	DrawString("\pWe DON'T perform charity cures!");					break;				}			else				{					GameChars[gCurChar].gold=GameChars[gCurChar].gold-						GameChars[gCurChar].level;									CurePoison();				}			break;				case 3:			/* RAISE DEAD ... friendly free service, no cost! */								RaiseDead();			break;		case 4:		/* BURY DEAD */				ZeroChar();			/** sorts & updates party **/				gPartyNum--;		/* subtract 1 from total dungeon party */				if (gPartyNum<=-1)	/* if less than 0 members, then leave */					{					gCurChar=-1;						ClearMessage();		 				DrawString("\pThere is no one left in your party.");										break;					} 				else					{					gCurChar=gDungParty[0];					gWhichChar=0;					}				UpdateAllNames();				ReplotChar();				ClearMessage(); 				DrawString("\pAshes to ashes, dust to dust. Rest In Peace.");				z=TRUE;			break;		}}/******************************* ZeroChar ****************************/ZeroChar()				/* zeros out old, dead chars */{int		x,z,y,xyz,tempDungParty[4],tempChar,temp2Char;Str255	theText;		GameChars[gCurChar].name[0]=0;		GameChars[gCurChar].level = 0;		GameChars[gCurChar].exp   = 0;		GameChars[gCurChar].status = 99;	/** 99 = open slot */				GameChars[gCurChar].age = 0;		GameChars[gCurChar].hits = 0;			GameChars[gCurChar].dmg=0;		GameChars[gCurChar].str = 0;		GameChars[gCurChar].con = 0;		GameChars[gCurChar].wis = 0;		GameChars[gCurChar].itl = 0;		GameChars[gCurChar].dex = 0;		GameChars[gCurChar].gold= 0; 		GameChars[gCurChar].bank = 0;		GameChars[gCurChar].Pos=-1;		for (x=0;x<=3;x++)					/* zero out all spells */		{			GameChars[gCurChar].mspells[x] = 0;			GameChars[gCurChar].cspells[x] = 0;			}				GameChars[gCurChar].dngLevel=0;		GameChars[gCurChar].xLoc=0;		GameChars[gCurChar].yLoc=0;	for (z=0;z<=6;z++)		{		GameChars[gCurChar].itemsInUse[z]=OPENSLOT;		GameChars[gCurChar].items[z]=OPENSLOT;		}		/************** NOW SORT AND UPDATE DUNGEON PARTY ****************/for (x=0;x<=3;x++)		/*  init.tempDungParty to empty slots */	tempDungParty[x]=99;z=0;					/* starting record of dungeon party array */ 	for (x=0;x<=3;x++)			  		{			if (GameChars[gDungParty[x]].status>=2 && 				GameChars[gDungParty[x]].status!=99)		/* LIVE CHARS */				{					tempDungParty[z]=gDungParty[x];			/* temp. array */					z++;				}		}							  	for (x=0;x<=3;x++)			  		{			if (GameChars[gDungParty[x]].status==DEAD || 	/* 0, 1 */				GameChars[gDungParty[x]].status==PERMDEAD)	/* DEADERS */				{					tempDungParty[z]=gDungParty[x];			/* temp. array */					z++;				}		} 	for (x=0;x<=3;x++)			  		{			if (GameChars[gDungParty[x]].status==99)		/* OPEN SLOTS */				{					tempDungParty[z]=99;			/* temp. array assigned open slot 99 */					z++;				}		}		  SetPort(gGameWindow);		/* now clear out data in window */for (x=0;x<=3;x++)			/* read char pointers into perm. array */	{		gDungParty[x]=tempDungParty[x];		gWhichChar=x;		ClearStats();	}}