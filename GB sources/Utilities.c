/*********************************                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /***********************************  GayBlade   Ver 1.0.0    ****     Utilities.c              ****   Programmed by Ryan Best    ****   ©Copyright 1992, Ryan Best ************************************/#include "GB.h"extern	WindowPtr	gPictureWindow, gGameWindow, gCastleWindow;extern	Boolean		gDone, gWNEImplemented;extern	EventRecord	gTheEvent;extern	MenuHandle	gAppleMenu,gFileMenu,gOptionsMenu,gSpecialMenu;extern	Rect		gIntroRect, gTavernRect, gBankRect, gRollerRect, gStoreRect, gCharRect0,					gCharRect1, gCharRect2, gCharRect3,gItemsRect, gMapRect, gSpellsRect,gSrcRect,					gGuildRect,gHealerRect,gdungeonRect, gStatsRect, gPartyInfoRect,					gUseRect,gPanicRect, gMoveRect, gDungDispRect, gActionRect,gConsoleRect, 					gMScreenRect,leftRect,centerRect,rightRect,cLeftRect,cCenterRect,cRightRect,					doorRect,clwallRect,crwallRect,cRect, gChestRect,gItemRect,gListStatsRect,					gListItemsRect, gCompassRect,gTreasureRect;extern	PicHandle	gThePicture, gConsolePicture, gDungeon1, gLeftWall, gCenterWall, gRightWall,					gLeftDoor,gRightDoor,gFlatWall,gFlatDoor,gOpenSpace,gFarWall,gFarDoor,gCLWall,gCRWall,					gCOpenSpace,gCLDoor,gCRDoor,gCFWall,gCFDoor, gMScreenPicture;extern	CIconHandle	gVialIcon,gShieldIcon, gRingIcon, gSphereIcon,gFlailIcon,gCloakIcon,gArrowIcon,gDaggerIcon,					gSwordIcon,gHelmetIcon,gTorchIcon,gBookIcon,gGlovesIcon,gBurnedIcon,gArmorIcon,					gChestIcon, gCompassIcon,gCNorthIcon,gCSouthIcon,gCEastIcon,					gCWestIcon;extern int			gSndOn,gPanicOn, gInCastle, gPartyNum,gNewChar, gSndNum, gLastChar, gLight,					gLightSpell,gItemUseScreen, gCurChar, gInPrison,gDialogNum,gDisplay,gDungLevel,gXLoc,gYLoc,					gView,gResistFire,gResistIce,gPartyInvis,gInEncounter,gCureWho,gFoundItems[3],					gCreatType, gCreatureCounter, gCreatHits[10],gLevelCount,dmgType,gTreasure,					gDisarmSpellCast,gCompass,ASave,gMagicItems[4],gSpeed,gCharShields[4],gEvade,					gCPUSpeed;extern	long		gStats[6], gDungParty[4],gWhichChar,glastWhen,gPanic;extern	Point		glastWhere;extern	DialogPtr	gCastleDialog;extern	RGBColor	gNameBack, gStatsBack, gSpecName,gNormName,gMessBack,gBlack,gStatsFore;extern	CCrsrHandle	gSpellCursor;extern	SFReply		fileName;extern	struct	CharInfo {	Str255	name;	int		type;	int		race;	int		level;	int		exp;	int		status;	int		hits;	int		dmg;	int		age;	int		str;	int		wis;	int		itl;	int		con;	int		dex;	int		items[7];		int		itemsInUse[7];			/* what items are being used */	int		gold;	int	 	bank;					/* released wizard? */	int		mspells[4],cspells[4];	int		dngLevel, xLoc, yLoc,Pos;	};extern	struct	CharInfo	GameChars[8];						/*  Can store up to 8 chars per game  */extern	struct	ItemInfo {	Str255			name;	unsigned char	type;	unsigned char	status;		/* whether item is in use or not */	unsigned char	instore;	unsigned char	level;	Byte			attrib;	unsigned char	dmg;	unsigned char	def;	unsigned char	con;};extern	struct	ItemInfo	GameItems[101];extern	struct	DungInfo 				{	unsigned int	XY[10][10];		/*  x, y  rooms location */	unsigned int	N[100];			/* 100 rooms w/north walls */	unsigned int	S[100];			/* 100 rooms w/south walls */	unsigned int	E[100];			/* 100 rooms w/east walls */	unsigned int	W[100];			/* 100 rooms w/west walls */	unsigned int	SA[100];};extern	struct	DungInfo	Dungeon[1];	extern struct	CreatureInfo 				/* access database each encounter */{	Str255			name;	unsigned char	type;	unsigned char	status;		/* For use in editor only */	unsigned char	instore;	/* Unused variable */	unsigned char	level;	Byte			attrib;	Byte			dmg;	Byte			def;	Byte			hits;};extern struct	CreatureInfo	GameCreatures[1];	/************************* GetRandomNum  ****************************/GetRandomNum(min,max)unsigned	min,max;{long		range,t;Str255		theText;unsigned	qdRdm;qdRdm=Random();	range=max-min;	t=(qdRdm*range)/65536;return(t+min);}/************************* ItemBurnout  ****************************/ItemBurnout(itemNum)int		itemNum;{long		burnOut;unsigned	min,max;min=0;max=100;burnOut=GetRandomNum(min,max);					/* get random number */if (burnOut<=GameItems[GameChars[gCurChar].items[itemNum]].con)	/* item burnt */	{		burnOut=TRUE;			ClearMessage();				DrawString("\pThe ");					switch (GameItems[GameChars[gCurChar].items[itemNum]].type)					{				 	case MAGICVIAL:			 						  DrawString("\pMagic Vial");					break;									 	case SWORD:			 						  DrawString("\pSword");					break;   					case DAGGER:			 						  DrawString("\pDagger");					break;					case SHIELD:			 						  DrawString("\pShield");					break;										case HELMET:			 						  DrawString("\pHelmet");					break;										case FLAIL:			 						  DrawString("\pFlail");					break;					case GAUNTLETS:			 						  DrawString("\pPurse");					break;						case CLOAK:			 						  DrawString("\pCloak");					break;					case TORCH:			 						  DrawString("\pLighter");					break;										case ARMOR:			 						  DrawString("\pArmor");					break;					case RING:			 						  DrawString("\pRing");					break;						case SPHERE:			 						  DrawString("\pSphere");					break;					}					DrawString("\p burned out!");						ModifyItem(itemNum);	/* modify item type */			Pause();		return(burnOut);	}else	{		burnOut=FALSE;		return(burnOut);	}}		/************************* CheckTorch  ****************************/CheckTorch(){	if (CheckIfOff()==NO)		/* torch did not burn out */		return;	else		CheckIfOn();}/************************* CheckIfOff  ****************************/CheckIfOff(){unsigned	min,max;int			x,y;long		burnOut;burnOut=GetRandomNum(min=0,max=100);		/* get random number */if (burnOut<=2)								/* 2% torch  burn out */	{	  for (x=0;x<=gPartyNum;x++)			/* check each char */	  {	  	for (y=0;y<=6;y++)					/* check each item */	  		{	  			if (GameItems[GameChars[gDungParty[x]].itemsInUse[y]].type==TORCH)	  			  {					burnOut=TRUE;						ClearMessage();							DrawString("\pA Lighter burned out!");									GameChars[gDungParty[x]].items[y]=100;	/* REC # OF BURNED ITEM IN DATABSE! */							GameChars[gDungParty[x]].itemsInUse[y]=OPENSLOT;							ReplotChar();							if (gLightSpell==OFF)								gLight=NO;		/* turn light off */							return(YES);					}			}	  }	} else					/* torch did not burn out */  	return(NO);}/************************* CheckIfOn  ****************************/CheckIfOn(){unsigned	min,max;int			x,y;long		burnOut;			for (x=0;x<=gPartyNum;x++)			/* check each char for EXTRA TORCH */	  {	  	for (y=0;y<=6;y++)					/* check each item */	  		{	  			if (GameItems[GameChars[gDungParty[x]].itemsInUse[y]].type==TORCH)	  				{						gLight=YES;		/* turn light off */						UpdateDV();						return;			/* now leave */											}				}	  }}	  						/************************* ModifyItem  ****************************/ModifyItem(itemNum){	GameChars[gCurChar].items[itemNum]=100;		/* REC # OF BURNED ITEM IN DATABSE! */ReplotChar();}/******************************* Pause **************************************/Pause()				/*** PAUSE utility program ***/{int				x;unsigned long	finalTick;long			thetime,secs; if (gSpeed==0)		/* slowest */	secs=Time+.40;else	secs=Time+.10;	while (Time!=secs)	/* empty time loop */	{	}}/******************************* PauseAnim **************************************/PauseAnim()				/*** PAUSE utility program ***/{int				z,x;unsigned long	finalTick;long			thetime,secs; Str255			theText;if (gCPUSpeed==2)		/* slow animation down for 68040  & greater CPUs */	secs=Ticks+.85;else					/* otherwise return */	return;	while (Ticks<=secs)	/* empty time loop */	{	}}/******************************* CalcDamage **************************************/CalcDamage(dmg,theChar)			/*** calculates total damage received ***/int		dmg,theChar;			/** MINUS any defensive items equipped or on **/{int			x,y,z,ztemp,def;Byte		totDamage;Str255		theText;def=0;									/* for percentage of damage */totDamage=0;							/* def = POINTS of protection */for (x=0;x<=6;x++)						/** NOTE: return with full damage, if no shielding! **/		def=def + GameItems[GameChars[gDungParty[theChar]].itemsInUse[x]].def;						 if (dmg-def >= 255)		/**  limited to BYTE [255 hits ]  **/    		totDamage = 255; 		else if (dmg-def<=0)		/* always get hit for at LEAST 1 hit */ 			totDamage=1; 		else   		    totDamage=dmg-def;		/**  results in damage minus any protection **/  return(totDamage);}/******************** CalcCreatureDamage **********************/CalcCreatureDamage()		/* dmgType = type of hit */{int				zcount,theChar,fx;Byte			totDamage;long			dmg,yy,xx,x,y;Str255			text;unsigned		min,max;	Str255			theText;CIconHandle		animIcon;Rect			fbRect,destRect,worldBounds;GWorldPtr		world;GWorldPtr		MakeGWorld();Rect			worldBounds2;GWorldPtr		world2;GWorldPtr		MakeGWorld2();GDHandle		oldGD;if (gCreatureCounter<=0)	return;									/* no creatures */	gPanic=NO;									/* for copybits routine */RGBForeColor(white);RGBBackColor(black);	SetRect(&worldBounds,33,33,364,299);						SetRect(&destRect,33,33,364,299);			world=MakeGWorld(&worldBounds);		/* first GWorld */	SetRect(&gMScreenRect,0,0,331,266);				CopyIntroBits(world,&gMScreenRect);			/* copy mRect screen */			switch (dmgType){	case FIREBALLS:		animIcon=GetCIcon(193);			for (x=0;x<=gCreatureCounter;x++)			{					gSndNum=13665;					PlaySound();			for (fx=0;fx<=6;fx++)			{				SetRect(&fbRect,165,236-(fx*6),197,268-(fx*6));							PlotCIcon(&fbRect,animIcon);				PauseAnim();		 		CopyWorldBits(world,&gMScreenRect);		/* Update console screen */			}						SetRect(&fbRect,149,140,213,204);						PlotCIcon(&fbRect,animIcon);					PauseAnim();						CopyWorldBits(world,&gMScreenRect);		/* Update console screen */			min=GameChars[gCurChar].itl;max=GameChars[gCurChar].itl*3;	/* damage range */			 	yy=GetRandomNum(min,max);									dmg=yy*4;				/* hard-coded damage here */						if (dmg>=gCreatHits[x])			/* death to creature */			{			ClearMessage();					DrawString("\pYou fried a ");					DrawString(GameCreatures[0].name);						DrawString("\p!");						GameChars[gCurChar].exp=GameChars[gCurChar].exp +					GameCreatures[0].level * 13;				Pause();			gCreatureCounter--;					/* subtract dead creature */			}		else			{			gCreatHits[x]=gCreatHits[x]-dmg;				ClearMessage();					DrawString("\pYou hit for ");						NumToString(dmg,theText);						DrawString(theText);					DrawString("\p hits!");				GameChars[gCurChar].exp=GameChars[gCurChar].exp+1;			Pause();			}	}	DisposeCIcon(animIcon);	DisposeGWorld(world);	break;					/* FIRE BALLS */		case LIGHTNINGBOLTS:	/* LIGHTNING BOLTS */		animIcon=GetCIcon(194);				for (x=0;x<=gCreatureCounter;x++)			{				gSndNum=13665;				PlaySound();			for (fx=0;fx<=3;fx++)				{				SetRect(&fbRect,165,236-(fx*11),197,268-(fx*11));								PlotCIcon(&fbRect,animIcon);				PauseAnim();								RGBForeColor(white);				RGBBackColor(black);   		 		CopyWorldBits(world,&gMScreenRect);		/* Update console screen */				}							SetRect(&fbRect,149,140,213,204);						PlotCIcon(&fbRect,animIcon);				PauseAnim();								CopyWorldBits(world,&gMScreenRect);		/* Update console screen */				min=0;max=100;					/* damage range */			 	yy=GetRandomNum(min,max);									dmg=yy*3;				/* hard-coded damage here */						if (dmg>=gCreatHits[x])			/* death to creature */			{			InvertRect(&gMScreenRect);			ClearMessage();				InvertRect(&gMScreenRect);							DrawString("\pYou zapped a ");					DrawString(GameCreatures[0].name);						DrawString("\p!");						GameChars[gCurChar].exp=GameChars[gCurChar].exp+					GameCreatures[0].level * 6;					Pause();			gCreatureCounter--;					/* subtract dead creature */			}		else			{			gCreatHits[x]=gCreatHits[x]-dmg;				ClearMessage();					DrawString("\pYou hit for ");						NumToString(dmg,theText);						DrawString(theText);					DrawString("\p hits!");				GameChars[gCurChar].exp=GameChars[gCurChar].exp+1;			Pause();			}	}	DisposeCIcon(animIcon);	DisposeGWorld(world);	break;		case EYEOFDEATH:	/* EYEOFDEATH */			animIcon=GetCIcon(198);							for (fx=0;fx<=3;fx++)				{				SetRect(&fbRect,165,236-(fx*11),197,268-(fx*11));								PlotCIcon(&fbRect,animIcon);				PauseAnim();								RGBForeColor(white);				RGBBackColor(black);   		 		CopyWorldBits(world,&gMScreenRect);		/* Update console screen */				}							SetRect(&fbRect,149,140,213,204);					PlotCIcon(&fbRect,animIcon);				PauseAnim();								CopyWorldBits(world,&gMScreenRect);		/* Update console screen */								ClearMessage();				DrawString("\pYou slimed a ");					DrawString(GameCreatures[0].name);						DrawString("\p to death!");				GameChars[gCurChar].exp=GameChars[gCurChar].exp+					GameCreatures[0].level * 6;				Pause();			gCreatureCounter--;					/* subtract dead creature */		DisposeCIcon(animIcon);		DisposeGWorld(world);	break;		case ICESTORM:	/* ICE STORM */				animIcon=GetCIcon(197);			for (x=0;x<=gCreatureCounter;x++)			{				for (fx=0;fx<=3;fx++)				{				SetRect(&fbRect,165,236-(fx*11),197,268-(fx*11));								PlotCIcon(&fbRect,animIcon);				PauseAnim();								RGBForeColor(white);				RGBBackColor(black);   		 		CopyWorldBits(world,&gMScreenRect);		/* Update console screen */				}							SetRect(&fbRect,149,140,213,204);						PlotCIcon(&fbRect,animIcon);				PauseAnim();								CopyWorldBits(world,&gMScreenRect);		/* Update console screen */							min=GameChars[gCurChar].itl;max=GameChars[gCurChar].itl*3;			 	yy=GetRandomNum(min,max);								dmg=yy*4;							if (dmg>=gCreatHits[x])				/* death to creature */			{			ClearMessage();				gSndNum=13665;					PlaySound();				DrawString("\pYou shattered a ");					DrawString(GameCreatures[0].name);						DrawString("\p!");						GameChars[gCurChar].exp=GameChars[gCurChar].exp +					GameCreatures[0].level * 6;				Pause();			gCreatureCounter--;					/* subtract dead creature */			}		else			{			gCreatHits[x]=gCreatHits[x]-dmg;				ClearMessage();					DrawString("\pYou hit for ");						NumToString(dmg,theText);						DrawString(theText);					DrawString("\p hits!");				GameChars[gCurChar].exp=GameChars[gCurChar].exp+1;			Pause();			}	}		DisposeCIcon(animIcon);		DisposeGWorld(world);	break;				case WOUND:	/* WOUND */		animIcon=GetCIcon(195);				for (x=0;x<=gCreatureCounter;x++)			{			gSndNum=23536;	 		 	 	 					PlaySound();				for (fx=0;fx<=4;fx++)			{				SetRect(&fbRect,165,236-(fx*11),197,268-(fx*11));								PlotCIcon(&fbRect,animIcon);				PauseAnim();								RGBForeColor(white);				RGBBackColor(black);   		 		CopyWorldBits(world,&gMScreenRect);		/* Update console screen */			}								min=1;max=7;					/* damage range */			 	yy=GetRandomNum(min,max);									dmg=yy+(GameChars[gCurChar].itl/3);											if (dmg>=gCreatHits[x])			/* death to creature */			{			ClearMessage();				DrawString("\pYou destroyed a ");					DrawString(GameCreatures[0].name);						DrawString("\p!");						GameChars[gCurChar].exp=GameChars[gCurChar].exp +					GameCreatures[0].level * 6;				Pause();			gCreatureCounter--;					/* subtract dead creature */			}		else			{			gCreatHits[x]=gCreatHits[x]-dmg;				ClearMessage();					DrawString("\pYou wounded for ");						NumToString(dmg,theText);						DrawString(theText);					DrawString("\p hits!");				GameChars[gCurChar].exp=GameChars[gCurChar].exp+1;			Pause();			}	}		DisposeCIcon(animIcon);		DisposeGWorld(world);	break;		case HEAVYWOUND:	/* HEAVY WOUND */	animIcon=GetCIcon(196);				for (x=0;x<=gCreatureCounter;x++)			{			gSndNum=23536;	 		 	 	 					PlaySound();			for (fx=0;fx<=4;fx++)				{				SetRect(&fbRect,165,236-(fx*11),197,268-(fx*11));								PlotCIcon(&fbRect,animIcon);				PauseAnim();								RGBForeColor(white);				RGBBackColor(black);   		 		CopyWorldBits(world,&gMScreenRect);		/* Update console screen */				}																	min=8;max=16;					/* damage range */			 	yy=GetRandomNum(min,max);									dmg=yy+(GameChars[gCurChar].itl/2);																		if (dmg>=gCreatHits[x])			/* death to creature */			{			ClearMessage();				DrawString("\pYou destroyed a ");					DrawString(GameCreatures[0].name);						DrawString("\p!");						GameChars[gCurChar].exp=GameChars[gCurChar].exp +					GameCreatures[0].level * 1;				Pause();			gCreatureCounter--;					/* subtract dead creature */			}		else			{			gCreatHits[x]=gCreatHits[x]-dmg;				ClearMessage();					DrawString("\pYou wounded for ");						NumToString(dmg,theText);						DrawString(theText);					DrawString("\p hits!");				GameChars[gCurChar].exp=GameChars[gCurChar].exp+1;			Pause();			}	  }	  	DisposeCIcon(animIcon);		DisposeGWorld(world);	break;		}		SetRect(&gMScreenRect,33,33,331,266);		/* double check rect */   }/********************** CheckSave *****************************/CheckSave(){int			itemType, stairway, itemHit,  dialogDone = FALSE; Handle		itemHandle;Rect		itemRect;Str255		theText;gDialogNum	=	7000;		ParamText("\pSave current game before quitting?","\p","\p","\p");	DoDialog();		while (dialogDone == FALSE)	{		ModalDialog(NIL_POINTER, &itemHit);			switch (itemHit)			{				case 1:		/* YES */					dialogDone = TRUE;					SetPort(gGameWindow);					DisposeDialog(gCastleDialog);					return(YES);					break;				case 2:		/* NO */					dialogDone = TRUE;					DisposeDialog(gCastleDialog);					SetPort(gGameWindow);					return(NO);					break;								}	}}/********************** CheckClose *****************************/CheckClose(){int			itemType, stairway, itemHit,  dialogDone = FALSE; Handle		itemHandle;Rect		itemRect;Str255		theText;gDialogNum	=	7000;		ParamText("\pThis game has not been saved yet. Save before closing?","\p","\p","\p");	DoDialog();		while (dialogDone == FALSE)	{		ModalDialog(NIL_POINTER, &itemHit);			switch (itemHit)			{				case 1:		/* YES */					dialogDone = TRUE;					SetPort(gGameWindow);					DisposeDialog(gCastleDialog);					return(YES);					break;				case 2:		/* NO */					dialogDone = TRUE;					DisposeDialog(gCastleDialog);					SetPort(gGameWindow);					return(NO);					break;								}	}}/********************** ReplotScreen *****************************/ReplotScreen(){	DrawPicture (gConsolePicture,&gConsoleRect);	/* draw main screen again */	if (gLight==ON || gLightSpell == ON)		UpdateDV();	else if (gInCastle==YES)		DrawPicture (gMScreenPicture, &gMScreenRect);}/************************ Click ****************************/Click()			/* plays clicking sound */{	gSndNum=19402;	PlaySound();}/************************ ClearMessage ****************************/ClearMessage(){	  SetPort(gGameWindow);	 		RGBForeColor(&gNormName);					RGBBackColor(&gMessBack);			MoveTo(40,284);			DrawString("\pÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊ");	MoveTo(40,284);}/************************ GenerateSpells ****************************/GenerateSpells(z)	int		z;{int	x,y;	for (y=0;y<=3;y++)		{		GameChars[gDungParty[z]].cspells[y] = 0;		GameChars[gDungParty[z]].mspells[y] = 0;		}		  		if (GameChars[gDungParty[z]].type==1)	/* sammie */			{ 	 		if (GameChars[gDungParty[z]].level>=5 && 	 				GameChars[gDungParty[z]].level<=6)	 				{	 				GameChars[gDungParty[z]].cspells[0] = 1;	 				}	 			else if (GameChars[gDungParty[z]].level>= 7 && 	 				GameChars[gDungParty[z]].level<=8)	 				{	 				GameChars[gDungParty[z]].cspells[0] = 2;	 				GameChars[gDungParty[z]].cspells[1] = 1;	 				}	 			else if (GameChars[gDungParty[z]].level>= 9)	 				{	 				GameChars[gDungParty[z]].cspells[0] = 3;	 				GameChars[gDungParty[z]].cspells[1] = 2;	 				GameChars[gDungParty[z]].cspells[2] = 1;	 					 				}	 			}		 	if (GameChars[gDungParty[z]].type==2 ||	 	GameChars[gDungParty[z]].type==5)	/* MAGE || MASTER */	 		{	 			if (GameChars[gDungParty[z]].level>=1 && 	 				GameChars[gDungParty[z]].level<=2)	 				GameChars[gDungParty[z]].mspells[0] = 1;	 					 			else if (GameChars[gDungParty[z]].level>=3 && 	 				GameChars[gDungParty[z]].level<=4)	 				{	 				GameChars[gDungParty[z]].mspells[0] = 2;	 				GameChars[gDungParty[z]].mspells[1]=1;	 				}	 			else if (GameChars[gDungParty[z]].level>=5 && 	 				GameChars[gDungParty[z]].level<=6)	 				{	 				GameChars[gDungParty[z]].mspells[0] = 3;	 				GameChars[gDungParty[z]].mspells[1] = 1;	 				}	 			else if (GameChars[gDungParty[z]].level>= 7 && 	 				GameChars[gDungParty[z]].level<=8)	 				{	 				GameChars[gDungParty[z]].mspells[0] = 4;	 				GameChars[gDungParty[z]].mspells[1] = 2;	 				GameChars[gDungParty[z]].mspells[2] = 1;	 					 				}	 			else if (GameChars[gDungParty[z]].level>= 9 && 	 				GameChars[gDungParty[z]].level<=10)	 				{	 				GameChars[gDungParty[z]].mspells[0] = 5;	 				GameChars[gDungParty[z]].mspells[1] = 3;	 				GameChars[gDungParty[z]].mspells[2] = 2;	 					 				}		 			else if (GameChars[gDungParty[z]].level>= 11 && 	 				GameChars[gDungParty[z]].level<=12)	 				{	 				GameChars[gDungParty[z]].mspells[0] = 6;	 				GameChars[gDungParty[z]].mspells[1] = 4;	 				GameChars[gDungParty[z]].mspells[2] = 3;	 					 				}	 			else if (GameChars[gDungParty[z]].level>= 13 && 	 				GameChars[gDungParty[z]].level<=14)	 				{	 				GameChars[gDungParty[z]].mspells[0] = 7;	 				GameChars[gDungParty[z]].mspells[1] = 5;	 				GameChars[gDungParty[z]].mspells[2] = 3;	 				GameChars[gDungParty[z]].mspells[3] = 1;	 					 					 				}	 			else if (GameChars[gDungParty[z]].level>= 15 && 	 				GameChars[gDungParty[z]].level<=16)	 				{	 				GameChars[gDungParty[z]].mspells[0] = 8;	 				GameChars[gDungParty[z]].mspells[1] = 6;	 				GameChars[gDungParty[z]].mspells[2] = 4;	 				GameChars[gDungParty[z]].mspells[3] = 1;	 					 					 				}		 			else if (GameChars[gDungParty[z]].level>= 17)	 				{	 				GameChars[gDungParty[z]].mspells[0] = 9;	 				GameChars[gDungParty[z]].mspells[1] = 7;	 				GameChars[gDungParty[z]].mspells[2] = 5;	 				GameChars[gDungParty[z]].mspells[3] = 1;	 					 					 				}		 		}	 					 						 					 				 					 					 				 		if (GameChars[gDungParty[z]].type==3)	/* WIZARD */				{	 			if (GameChars[gDungParty[z]].level>=1 && 	 				GameChars[gDungParty[z]].level<=4)	 				GameChars[gDungParty[z]].mspells[0] = 1;	 					 			else if (GameChars[gDungParty[z]].level>=5 && 	 				GameChars[gDungParty[z]].level<=6)	 				{	 				GameChars[gDungParty[z]].mspells[0] = 2;	 				GameChars[gDungParty[z]].mspells[1]=1;	 				}	 			else if (GameChars[gDungParty[z]].level>=7 && 	 				GameChars[gDungParty[z]].level<=8)	 				{	 				GameChars[gDungParty[z]].mspells[0] = 3;	 				GameChars[gDungParty[z]].mspells[1] = 1;	 				}	 			else if (GameChars[gDungParty[z]].level>= 9 && 	 				GameChars[gDungParty[z]].level<=10)	 				{	 				GameChars[gDungParty[z]].mspells[0] = 4;	 				GameChars[gDungParty[z]].mspells[1] = 2;	 				GameChars[gDungParty[z]].mspells[2] = 1;	 					 				}	 			else if (GameChars[gDungParty[z]].level>= 11 && 	 				GameChars[gDungParty[z]].level<=12)	 				{	 				GameChars[gDungParty[z]].mspells[0] = 5;	 				GameChars[gDungParty[z]].mspells[1] = 3;	 				GameChars[gDungParty[z]].mspells[2] = 2;	 					 				}		 			else if (GameChars[gDungParty[z]].level>= 13 && 	 				GameChars[gDungParty[z]].level<=14)	 				{	 				GameChars[gDungParty[z]].mspells[0] = 6;	 				GameChars[gDungParty[z]].mspells[1] = 4;	 				GameChars[gDungParty[z]].mspells[2] = 3;	 					 				}	 			else if (GameChars[gDungParty[z]].level>= 15 && 	 				GameChars[gDungParty[z]].level<=16)	 				{	 				GameChars[gDungParty[z]].mspells[0] = 7;	 				GameChars[gDungParty[z]].mspells[1] = 5;	 				GameChars[gDungParty[z]].mspells[2] = 3;	 				GameChars[gDungParty[z]].mspells[3] = 1;	 					 					 				}	 			else if (GameChars[gDungParty[z]].level>= 17 && 	 				GameChars[gDungParty[z]].level<=18)	 				{	 				GameChars[gDungParty[z]].mspells[0] = 8;	 				GameChars[gDungParty[z]].mspells[1] = 6;	 				GameChars[gDungParty[z]].mspells[2] = 4;	 				GameChars[gDungParty[z]].mspells[3] = 1;	 					 					 				}		 			else if (GameChars[gDungParty[z]].level>= 19)	 				{	 				GameChars[gDungParty[z]].mspells[0] = 9;	 				GameChars[gDungParty[z]].mspells[1] = 7;	 				GameChars[gDungParty[z]].mspells[2] = 5;	 				GameChars[gDungParty[z]].mspells[3] = 1;	 					 					 				}		 		}					if (GameChars[gDungParty[z]].type==4 ||		GameChars[gDungParty[z]].type==5)	/* PRIEST  or MASTER */	 		{	 			if (GameChars[gDungParty[z]].level>=1 && 	 				GameChars[gDungParty[z]].level<=2)	 				GameChars[gDungParty[z]].cspells[0] = 1;	 					 			else if (GameChars[gDungParty[z]].level>=3 && 	 				GameChars[gDungParty[z]].level<=4)	 				{	 				GameChars[gDungParty[z]].cspells[0] = 2;	 				GameChars[gDungParty[z]].cspells[1]=1;	 				}	 			else if (GameChars[gDungParty[z]].level>=5 && 	 				GameChars[gDungParty[z]].level<=6)	 				{	 				GameChars[gDungParty[z]].cspells[0] = 3;	 				GameChars[gDungParty[z]].cspells[1] = 1;	 				}	 			else if (GameChars[gDungParty[z]].level>= 7 && 	 				GameChars[gDungParty[z]].level<=8)	 				{	 				GameChars[gDungParty[z]].cspells[0] = 4;	 				GameChars[gDungParty[z]].cspells[1] = 2;	 				GameChars[gDungParty[z]].cspells[2] = 1;	 					 				}	 			else if (GameChars[gDungParty[z]].level>= 9 && 	 				GameChars[gDungParty[z]].level<=10)	 				{	 				GameChars[gDungParty[z]].cspells[0] = 5;	 				GameChars[gDungParty[z]].cspells[1] = 3;	 				GameChars[gDungParty[z]].cspells[2] = 2;	 					 				}		 			else if (GameChars[gDungParty[z]].level>= 11 && 	 				GameChars[gDungParty[z]].level<=12)	 				{	 				GameChars[gDungParty[z]].cspells[0] = 6;	 				GameChars[gDungParty[z]].cspells[1] = 4;	 				GameChars[gDungParty[z]].cspells[2] = 3;	 					 				}	 			else if (GameChars[gDungParty[z]].level>= 13 && 	 				GameChars[gDungParty[z]].level<=14)	 				{	 				GameChars[gDungParty[z]].cspells[0] = 7;	 				GameChars[gDungParty[z]].cspells[1] = 5;	 				GameChars[gDungParty[z]].cspells[2] = 3;	 				GameChars[gDungParty[z]].cspells[3] = 1;	 					 					 				}	 			else if (GameChars[gDungParty[z]].level>= 15 && 	 				GameChars[gDungParty[z]].level<=16)	 				{	 				GameChars[gDungParty[z]].cspells[0] = 8;	 				GameChars[gDungParty[z]].cspells[1] = 6;	 				GameChars[gDungParty[z]].cspells[2] = 4;	 				GameChars[gDungParty[z]].cspells[3] = 1;	 					 					 				}		 			else if (GameChars[gDungParty[z]].level>= 17)	 				{	 				GameChars[gDungParty[z]].cspells[0] = 9;	 				GameChars[gDungParty[z]].cspells[1] = 7;	 				GameChars[gDungParty[z]].cspells[2] = 5;	 				GameChars[gDungParty[z]].cspells[3] = 1;	 					 					 				}		 		}			}	/************************* DBErrors  ****************************/DBErrors(dferror)int		dferror;{if (dferror==1)	{	ParamText("\pDatafile 'Dungeon' is either corrupt or missing.","\pRe-install from Master disks.","\p","\p");		NoteAlert(6000,NIL_POINTER);	ExitToShell();		}if (dferror==2)	{	ParamText("\pDatafile 'GBCreatures' is either corrupt or missing.","\pRe-install from Master disks.","\p","\p");		NoteAlert(6000,NIL_POINTER);	ExitToShell();		}	if (dferror==3)	{	ParamText("\pDatafile 'GBItems' is either corrupt or missing.","\pRe-install from Master disks.","\p","\p");		NoteAlert(6000,NIL_POINTER);	ExitToShell();		}	}/************************* TorchMessage  ****************************/TorchMessage(){int		x;for (x=0;x<=gPartyNum;x++)		{		if (GameChars[gDungParty[x]].level>=3)			return;	}	Pause();	ClearMessage();	DrawString("\pDon't forget to light a lighter!");	Pause();	ClearMessage();	DrawString("\pDon't forget to light a lighter!");		Pause();	ClearMessage();	DrawString("\pDon't forget to light a lighter!");}/************************* WizardChamber  ****************************/WizardChamber(){int			x,z;short		rsrcFileNum;unsigned	min,max;GrafPtr		oldPort;Rect		Sphere1Rect,Sphere2Rect,Sphere3Rect;Point		mouseLoc;	SetRect(&Sphere1Rect,105,220,145,242);		SetRect(&Sphere2Rect,155,220,200,242);	SetRect(&Sphere3Rect,215,220,255,242);				gSndNum=32072;			 			PlaySound();			ClearMessage();			DrawString("\pYou have entered the Empress' Chamber!");				rsrcFileNum=OpenResFile("\pGBW.data");	/*  open PICT resource file */		if (ResError())		{			ParamText("\pThere is a problem with file 'GBW.data'.",0,0,0);				NoteAlert(6000,NIL_POINTER);			ExitToShell();		}gMScreenPicture = GetPicture(161);	DrawPicture (gMScreenPicture, &gMScreenRect);	CloseResFile(rsrcFileNum);	 			/* now close resource file */DetachResource( gMScreenPicture);  	FlushEvents (everyEvent, REMOVE_ALL_EVENTS);	/* clear events before going to loop */	Pause();Pause();	ClearMessage();	DrawString("\pChoose a sphere, but choose wiselyÉ");		z=FALSE;	while (z!=TRUE)						/* give each char a chance */		  {			if (gWNEImplemented)				WaitNextEvent(everyEvent,&gTheEvent,MIN_SLEEP,NIL_MOUSE_REGION);			else				{					SystemTask();					SndTask();					GetNextEvent(everyEvent, &gTheEvent);				}					switch (gTheEvent.what)		case mouseDown:						/* only look for mousedown event */			GetMouse(&mouseLoc);					if (PtInRect(mouseLoc, &Sphere1Rect))				{			gSndNum=25631;					/* teleport sound */				PlaySound(); 				gMScreenPicture = GetPicture(402);	/* castle */								gInCastle=YES;				/** back to home!  **/					TheCastle();				 		DrawPicture (gMScreenPicture, &gMScreenRect);						ClearMessage();					DrawString("\pYou have failed and been returned home.");				z=TRUE;				return;				}		else if (PtInRect(mouseLoc, &Sphere2Rect))				{			gSndNum=25631;					/* teleport sound */				PlaySound();				ClearMessage();					DrawString("\pYou failed and have been teleported!");						gLevelCount=GetRandomNum(min=5,max=12);						InitDungeon();					ReadDungeon();				UpdateDV();					DetachResource( gMScreenPicture); 	 					gMScreenPicture = GetPicture(402);	/* castle */								z=TRUE;				return;				}										else if (PtInRect(mouseLoc, &Sphere3Rect))				{				ClearMessage();					DrawString("\pStrange things begin to happen!");				z=TRUE;				Pause();Pause();Pause();				}   }  	gSndNum=17096;					/* intro music */		PlaySound();			rsrcFileNum=OpenResFile("\pGBW.data");	/*  open PICT resource file */	if (ResError())	{		ParamText("\pThere is a problem with file 'GBW.data'.",0,0,0);			NoteAlert(6000,NIL_POINTER);		ExitToShell();	}					for (x=0;x<=3;x++)					/* entry screen */{	gMScreenPicture = GetPicture(162);	DrawPicture (gMScreenPicture, &gMScreenRect);	gMScreenPicture = GetPicture(161);	DrawPicture (gMScreenPicture, &gMScreenRect);}	   for (x=0;x<=2;x++){	gMScreenPicture = GetPicture(163);	DrawPicture (gMScreenPicture, &gMScreenRect);	gMScreenPicture = GetPicture(164);	DrawPicture (gMScreenPicture, &gMScreenRect);}Pause();Pause();	gSndNum=32072;			 			PlaySound(); 	gSndNum=17096;					/* intro music */		PlaySound();			for (x=0;x<=1;x++){	gMScreenPicture = GetPicture(164);	DrawPicture (gMScreenPicture, &gMScreenRect);	gMScreenPicture = GetPicture(165);	DrawPicture (gMScreenPicture, &gMScreenRect);}Pause();Pause();Pause();CloseResFile(rsrcFileNum);	 					/* now close resource file */	DetachResource( gMScreenPicture); 		rsrcFileNum=OpenResFile("\pGBW.data");			/*  open PICT resource file */		gMScreenPicture = GetPicture(166);			/* outside world screen */			DrawPicture (gMScreenPicture, &gMScreenRect);			Pause();Pause();Pause();Pause();				CloseResFile(rsrcFileNum);	 			/* now close resource file */DetachResource( gMScreenPicture); 	gMScreenPicture = GetPicture(129);			/* do not rejoice yet screen */			DrawPicture (gMScreenPicture, &gMScreenRect);	WaitForMouseClick();				gMScreenPicture = GetPicture(136);		/* ad screen */			DrawPicture (gMScreenPicture, &gMScreenRect);		ClearMessage();		DrawString("\pYou have won! Click mouse to continueÉ");		WaitForMouseClick();			gSndNum=25631;						/* teleport sound */		PlaySound();			Pause();							/* let sound play */ 		gMScreenPicture = GetPicture(402);	/* castle */		gInCastle=YES;						/** back to home!  **/		TheCastle();	 		DrawPicture (gMScreenPicture, &gMScreenRect);				for (x=0;x<=gPartyNum;x++)			/* raise all perm/dead chars! */	{		GameChars[gDungParty[x]].status=2;		GameChars[gDungParty[x]].dmg=0;			}			TheCastle();	UpdateAll();	for (x=0;x<=gPartyNum;x++)	GameChars[gDungParty[x]].bank=99;	/* char can't enter wiz. chamber */						}/********************** PartyInfo *****************************/PartyInfo()			/* PartyInfo */{if (gDungParty[0]==99)	/* don't do nothing if no char */	return;ClearMessage();if (gResistFire==ON)	DrawString("\pResist-FireÊÊ");if (gResistIce==ON)	DrawString("\pResist-IceÊÊ");if (gPartyInvis==ON)	DrawString("\pParty-InvisÊÊ");if (gResistFire==ON || gResistIce==ON || gPartyInvis==ON)	DrawString("\pON");	else if (gLightSpell==OFF && gResistFire==OFF && gResistIce==OFF && gPartyInvis==OFF)	DrawString("\pNo spells are currently castÉ");		Pause();Pause();}/********************** ExtinguishTrap *****************************/ExtinguishTrap()			/* PartyInfo */{	ClearMessage();		DrawString("\pYou hit a trap!");		AllSpellsOff();			TorchAndLightOff();	UpdateDV();}/********************** CheckPoisonedChars *****************************/CheckPoisonedChars()			/* this routined subtracts one hit per step */{int		tempChar,tempWhichChar,x;for (x=0;x<=gPartyNum;x++)  if (GameChars[gDungParty[x]].status==POISONED)  	{	ClearMessage();			DrawString(GameChars[gDungParty[x]].name);DrawString("\p lost a hit!");			GameChars[gDungParty[x]].dmg++;				RGBBackColor(&gStatsBack);			if (GameChars[gDungParty[x]].dmg>=GameChars[gDungParty[x]].hits)				{				ClearMessage();						DrawString(GameChars[gDungParty[x]].name);					DrawString("\p died from poisoning!");					GameChars[gDungParty[x]].status=DEAD;  	/* DEAD */				DeadChar();							/* TURN OFF ALL Stuff */				}			else									/* UPDATE FOR CHAR */				{				tempChar=gCurChar;					tempWhichChar=gWhichChar;					gCurChar=gDungParty[x];						gWhichChar=x;					gCurChar=tempChar;				gWhichChar=tempWhichChar;				}	UpdateAllNames();			/* only update when poisoned char in party */				}}		/********************** CheckPartyStatus *****************************/CheckPartyStatus()		/*** used to check status of party damage ***/{int		x,bodyCount=-1;Str255	theText; for (x=0;x<=gPartyNum;x++) 			/** ENTIRE PARTY DEAD?? **/		{	if (GameChars[gDungParty[x]].status == DEAD ||		GameChars[gDungParty[x]].status == PERMDEAD ||		GameChars[gDungParty[x]].status == 99)			bodyCount++;			}		if (bodyCount == gPartyNum)	  /* ENTIRE PARTY DEAD!  */		return(YES);			else		return(NO);	}/********************** DeadCharMsg *****************************/DeadCharMsg(){int		z,x;		if (GameChars[gCurChar].status==DEAD)	{		ClearMessage();		DrawString(GameChars[gCurChar].name);		DrawString("\p is DEAD!");		z=-1;	}	else if (GameChars[gCurChar].status==PERMDEAD)	/* DEAD */	{		ClearMessage();		DrawString(GameChars[gCurChar].name);		DrawString("\p is PERM DEAD!");		z=-1;	}  return(z);}/*********************** DeadChar ******************************/DeadChar()					/* update stats & stuff for dead char */{int		x,z,y,tempDungParty[4];for (x=0;x<=gPartyNum;x++)		/*  init.tempDungParty to empty slots */	tempDungParty[x]=99;z=gPartyNum;					/* sort all DEAD chars first, put in  */for (x=gPartyNum;x>=0;x--)		/* rear of party  */ 	 {  		if (GameChars[gDungParty[x]].status==PERMDEAD || 	/* PERM dead or */			 GameChars[gDungParty[x]].status==DEAD)			/* DEAD chars */				{				for (y=0;y<=6;y++)							/* turn chars items off */					GameChars[gDungParty[x]].itemsInUse[y]=OPENSLOT;				tempDungParty[z]=gDungParty[x];				/* temp. array */				z--;				}	 }		z=0;								/* sort all LIVE chars now  */for (x=0;x<=gPartyNum;x++)			/* and put in front of party  */ 	 {  		if (GameChars[gDungParty[x]].status>=2 &&			  GameChars[gDungParty[x]].status<99)			/* LIVE chars */				{				tempDungParty[z]=gDungParty[x];				/* temp. array */				z++;				}	 }		for (x=0;x<=7;x++)					/* re-inits ALL chars (even in Tav.) */	GameChars[x].Pos=-1;for (x=0;x<=gPartyNum;x++)			/* read temp into perm. array */	{		gDungParty[x]=tempDungParty[x];			GameChars[gDungParty[x]].Pos=-1;	/* re-init all char positions */				GameChars[gDungParty[x]].Pos=x;		/* now store accurate Pos. */	}		gCurChar=gDungParty[0];			gWhichChar=0;  /**** NOW CHECK TORCHES ******/if (gPartyNum>=0){gLight=OFF;	  for (x=0;x<=gPartyNum;x++)		/* check each char */	  {	  	for (y=0;y<=6;y++)				/* check each item */	  		{	  			if (GameItems[GameChars[gDungParty[x]].itemsInUse[y]].type==TORCH	  				|| gLightSpell==ON)						gLight=ON;		/* turn light ON */			}	  }}  AutoSave();	}/********************** AllSpellsOff **************************/AllSpellsOff()			/* turn OFF all spells (AND TORCHES) in use for whatever reason */{int		z,x;	gResistFire=OFF;			/* protective spells Off */	gResistIce=OFF;				/* protective spells Off */	gPartyInvis=OFF;			/* protective spells Off */	gLightSpell=OFF;			/* light spell not cast */	gCompass=OFF;				/* compass spell OFF */}/********************** TorchAndLightOff **************************/TorchAndLightOff()			/* turn OFF ALL TORCHES & LIGHT SPELLS */{int		z,x;for (x=0;x<=gPartyNum;x++)	for (z=0;z<=6;z++)		{			if (GameItems[GameChars[gDungParty[x]].itemsInUse[z]].type==TORCH)					GameChars[gDungParty[x]].itemsInUse[z]=OPENSLOT;		}			gLight=OFF;			/* turn EVERY torch OFF */		gLightSpell=OFF;		/* turn light spell off */	LightOff();					/* paint screen black */  ReplotChar();					/* replot current char's stats/item's screen */}/********************** TorchAndLightOn **************************/TorchAndLightOn()			/* Check all torches if on */{int		z,x;  for (x=0;x<=gPartyNum;x++)	for (z=0;z<=6;z++)		{			if (GameItems[GameChars[gDungParty[x]].itemsInUse[z]].type==TORCH)			gLight=ON;			/* turn light on */		}}/********************** PartyDead *****************************/PartyDead(){int			itemType, stairway, itemHit,  dialogDone = FALSE; Handle		itemHandle;Rect		itemRect;Str255		theText;gDialogNum	=	7000;ResetParty();		/* all ITEMS/SPELLS off ..except party spells */AutoSave();		ParamText("\pThe dungeon has claimed your soul! ","\pDo you want to try again?","\p","\p");	DoDialog();		while (dialogDone == FALSE)	{		ModalDialog(NIL_POINTER, &itemHit);			switch (itemHit)			{				case 1:		/* YES */					dialogDone=TRUE;										DisposeDialog(gCastleDialog);							SetPort(gGameWindow); 							gPanic=YES;							DrawPicture (gConsolePicture,&gConsoleRect);					 	DrawPicture (gMScreenPicture, &gMScreenRect);					gInCastle=YES;					ClearMessage();		/* wipe out any extra junk in mssg. box */					break;				case 2:		/* NO */					DisposeDialog(gCastleDialog);					SetPort(gGameWindow);									ExitToShell();					break;								}	}}/********************** ResetParty *****************************/ResetParty()			/* Entire party dead, ZERO ALL */{int		z,x;for (z=0;z<=gPartyNum;z++)						 	{		GameChars[gDungParty[z]].name[0]=0;			GameChars[gDungParty[z]].status=99;			GameChars[gDungParty[z]].Pos=-1;		gDungParty[z]=99;		}		AllSpellsOff();				/** turn off all spells **/	PartyItemsOff();			/** turn off ALL party items **/	gLight=OFF;					/** turn off torch if on **/	gPartyNum=-1;				/* no one in party */	gInEncounter=NO;			/* no active encounter */	gItemUseScreen=NO;			/* not trying to use any item, yet*/	gInCastle=YES;	gCureWho=OFF;				/* for cure/raise spells */	gLevelCount=0;				/* USED FOR READING DATAFILE! */	}/********************** ReplotChar *****************************/ReplotChar()			/* Replot Current Chars screen */{int		z,x;if (gDisplay==0)			/* ITEMS */	ListItems();else	UpdateStats();}/********************** CheckPartyDamage *****************************/CheckPartyDamage()			/* Check damage, do appropriate thing */{int		x,z;for (x=0;x<=gPartyNum;x++)	/* NOW CHECK DEATHS */  { 	if (GameChars[gDungParty[x]].dmg>=GameChars[gDungParty[x]].hits &&		GameChars[gDungParty[x]].status >=2 &&		GameChars[gDungParty[x]].status <=99)		{			GameChars[gDungParty[x]].status=DEAD;	/* if dead, do DEAD CHAR */			InvertRect(&gMScreenRect);	/* invert when char dies */						gSndNum=30601;		 	 		 		 	 	 					PlaySound();			InvertRect(&gMScreenRect);				for (z=0;z<=6;z++)						/* turn chars items off */					GameChars[gDungParty[x]].itemsInUse[z]=OPENSLOT;			DeadChar();		}  }  if (CheckPartyStatus()==YES)	/* if ENTIRE party is dead, then reset it */	PartyDead();else	UpdateAllNames();			/* updates main info on top for damage */}/********************** UpdateAllNames *****************************/UpdateAllNames()			/* UpdateAllNames, not stats */{int		x,y,tempCurChar,tempWhichChar;tempCurChar=gCurChar;		/* read temp. values in */tempWhichChar=gWhichChar;	for (x=0;x<=gPartyNum;x++)	{		gCurChar=gDungParty[x];			gWhichChar=x;		UpdateName();		/* takes care of normal names/dead names updates*/		}gCurChar=tempCurChar;		/* now exchange */gWhichChar=tempWhichChar;}/********************** StairUp *****************************/StairUp(){int			itemType, stairway, itemHit,  dialogDone = FALSE; Handle		itemHandle;Rect		itemRect;Str255		theText;gDialogNum	=	7000;		ParamText("\pYou have found a stairway up!  Do you wish to use it?","\p","\p","\p");	DoDialog();		while (dialogDone == FALSE)	{		ModalDialog(NIL_POINTER, &itemHit);			switch (itemHit)			{				case 1:		/* YES */					dialogDone = TRUE;					SetPort(gGameWindow);					DisposeDialog(gCastleDialog);					gLevelCount--;					if (gLevelCount >= 0)	/* if 0 you're on level 1! */					{						ReadDungeon();    	/* don't read dungeon if in castle */						InitDungeon();		/* read in new walls */					}					else						TheCastle();					break;				case 2:		/* NO */					dialogDone = TRUE;					DisposeDialog(gCastleDialog);					SetPort(gGameWindow);					break;								}	}}/********************** StairDown *****************************/StairDown(){int			itemType, stairway, itemHit,  dialogDone = FALSE; Handle		itemHandle;Rect		itemRect;Str255		theText;gDialogNum	=	7000;		ParamText("\pYou have found a stairway down.  Do you wish to use it?","\p","\p","\p");	DoDialog();		while (dialogDone == FALSE)	{		ModalDialog(NIL_POINTER, &itemHit);			switch (itemHit)			{				case 1:		/* YES */					dialogDone = TRUE;					gLevelCount++;		/* used for reading next dung. level */					InitDungeon();		/* read in new walls */					ReadDungeon();					DisposeDialog(gCastleDialog);					SetPort(gGameWindow);					UpdateDV();					break;				case 2:		/* NO */					DisposeDialog(gCastleDialog);					return;					break;								}	}}/******************** Button up/down **********************/ButtonUpDown(){Rect			rect,buttonRect,sourceRect;		/* Temporary rect used for the pict & gworld. */ CGrafPtr		currentPort,currentPort2;		/* Port used before switching to the gworld's. */GDHandle		currentDevice,currentDevice2;	/* GDevice used before switching to the gworld's. */GWorldPtr		TempGWorld,TempGWorld2;	PixMapHandle	TempPixMap,TempPixMap2;			//  Needed PixMapHandle to lock down.		PicHandle		buttonPict;int				secs;buttonPict = GetPicture(139);							/* get DOWN button */			SetRect(&rect,0,0,200,150);							/* BUTTON PAD gworld */		NewGWorld( &TempGWorld, 0, &rect, nil , nil, 0 );	TempPixMap = GetGWorldPixMap( TempGWorld );			//  Get the GWorlds Pixmaphandle	LockPixels( TempPixMap );							//  Lock it down	GetGWorld( &currentPort, &currentDevice );		//  Save screen environment	SetGWorld( TempGWorld, nil );					//	Make screen GWorld current	SetRect(&buttonRect,0,0,151,24);					/* DOWN button gworld */	NewGWorld( &TempGWorld2, 0, &rect, nil , nil, 0 );	TempPixMap2 = GetGWorldPixMap( TempGWorld2 );		//  Get the GWorlds Pixmaphandle	LockPixels( TempPixMap2 );							//  Lock it down	GetGWorld( &currentPort2, &currentDevice2 );	//  Save gworld environment	SetGWorld( TempGWorld2, nil );					// set to gworld2 for DOWN button			RGBForeColor(white);		RGBBackColor(black);		SetRect(&sourceRect,317,0,517,150);				/* COPY BUTTON PAD */		SetRect(&rect,0,0,200,150);		CopyBits ( &(*gGameWindow).portBits, 		&(((GrafPtr) TempGWorld)->portBits), &sourceRect, &rect, 0, nil );							SetRect(&buttonRect, 0, 0, 151, 24);		DrawPicture(buttonPict, &buttonRect);		/*  draw DOWN button pict */		ReleaseResource(buttonPict);	TextFont(3);									/* set font */		RGBForeColor(&gNormName);					/* set frgcolor color to blue */				RGBBackColor(&gNameBack);					/* set bckgrnd color */	 MoveTo(9,17);DrawString(GameChars[gCurChar].name);			MoveTo(87,17);UpdateName2();							/* hits */					/* below COPIES from gworlds to screens */			switch (gWhichChar)			/* set rect coords for approp. char */			{				case 0:							SetRect(&buttonRect, 359, 39, 510, 63);					break;				case 1:							SetRect(&buttonRect, 359, 68, 510, 92);					break;				case 2:							SetRect(&buttonRect, 359, 97, 510, 121);					break;				case 3:							SetRect(&buttonRect, 359, 126, 510, 150);					break;			}			/* BELOW copies both gworlds to screen */						SetGWorld( currentPort, currentDevice );		/*  now set back to screen */	SetPort(gGameWindow);							/*  redundant call but..... */					RGBForeColor(white);		RGBBackColor(black);							SetRect(&sourceRect, 0, 0, 151, 24);				/* DOWN button copy */		// draw saved stuff in GWorld2 back to main screen	CopyBits (&(((GrafPtr) TempGWorld2)->portBits), 		&(*gGameWindow).portBits, &sourceRect, &buttonRect, 0, nil );			if (gDisplay==0)		/* update stats/items on screen */		ListItems();						  			else 		UpdateButton();				SetGWorld( currentPort, currentDevice );		/*  now set back to screen */	SetPort(gGameWindow);							/*  redundant call but..... */	RGBForeColor(white);	RGBBackColor(black);			SetRect(&sourceRect,317,0,517,150);					/* COPY SCREEN */	SetRect(&rect,0,0,200,150);			CopyBits (&(((GrafPtr) TempGWorld)->portBits), 		/* main screen copy */		&(*gGameWindow).portBits, &rect, &sourceRect, 0, nil );			DisposeGWorld(TempGWorld);							// this is a temp GWorld so lets get our memory back		DisposeGWorld(TempGWorld2);							// this is temp GWorld so lets get our memory back}/******************************* BPause **************************************/BPause()				/*** PAUSE utility program ***/{long			secs; unsigned long	finalTick;	secs=Time+.02;	while (Time!=secs)	/* empty time loop */	{	}}/********************** Panic *****************************/Panic(){int				itemType, panic, itemHit, x, dialogDone = FALSE,				yy,xx,width, height, sWidth, sHeight,h,w,v; Handle			itemHandle;Str255			theText;Rect			itemRect,destRect,worldBounds,totalRect, r,screenRect,				*boundsPtr;GWorldPtr		world;GWorldPtr		MakeGWorld();gPanic=YES;RGBForeColor(white);RGBBackColor(black);		SetRect(&destRect,0,0,517,369);		SetRect(&worldBounds,0,0,517,369);			world=MakeGWorld(&worldBounds);			 	CopyIntroBits(world,&gConsoleRect);	/*	copy current screen */HiliteMenu(1);		  gDialogNum=5000;	gCastleDialog=GetNewDialog(gDialogNum, NIL_POINTER, MOVE_TO_FRONT);				/* Positions dialog window  */			r=gCastleDialog->portRect;				width=r.right - r.left;		height=r.bottom - r.top;		sWidth=screenBits.bounds.right-screenBits.bounds.left;		sHeight=screenBits.bounds.bottom-screenBits.bounds.top;		h=screenBits.bounds.left + ((sWidth-width)/2);		v=screenBits.bounds.top + ((sHeight-height)/2)+10;	MoveWindow(gCastleDialog,h,v,FALSE);	SelectWindow(gCastleDialog);			ShowWindow(gCastleDialog);	SetPort(gCastleDialog);		GetDItem(gCastleDialog, 3, &itemType, &itemHandle, &itemRect);	SetCtlValue(itemHandle, ON);			GetDItem(gCastleDialog, 1, &itemType, &itemHandle, &itemRect);	HiliteControl(itemHandle,255);	while (dialogDone == FALSE)	{		ModalDialog(NIL_POINTER, &itemHit);			switch (itemHit)			{				case 1:		/* BEGIN */					DisposeDialog(gCastleDialog);					dialogDone = TRUE;					SetPort(gGameWindow);					RGBForeColor(white);					RGBBackColor(black);					CopyWorldBits(world,&gConsoleRect);	/* copy off screen */					DisposeGWorld ( world );				break;			}	}}/******************** WaitForMouseClick ************************************/WaitForMouseClick(){int				z=FALSE;FlushEvents (everyEvent, REMOVE_ALL_EVENTS);	/* clear events before going to loop */   		while (z!=TRUE)						/* give each char a chance */		  {			if (gWNEImplemented)				WaitNextEvent(everyEvent,&gTheEvent,MIN_SLEEP,NIL_MOUSE_REGION);			else				{					SystemTask();					SndTask();					GetNextEvent(everyEvent, &gTheEvent);				}								switch (gTheEvent.what)				{					case mouseDown:			/* only look for mousedown event */						z=TRUE;					break;						}				} }