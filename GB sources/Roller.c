/****************************************                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /***********************************        GayBlade   Ver 1.0.0         ****      © Copyright by Ryan Best 1992  ****          All Rights Reserved.       *******************************************/#include "GB.h"extern	WindowPtr	gPictureWindow, gGameWindow, gCastleWindow;extern	Boolean		gDone, gWNEImplemented;extern	EventRecord	gTheEvent;extern	MenuHandle	gAppleMenu,gFileMenu,gOptionsMenu,gSpecialMenu;extern	Rect		gIntroRect, gTavernRect, gBankRect, gRollerRect, gStoreRect, gCharRect0,					gCharRect1, gCharRect2, gCharRect3,gItemsRect, gMapRect, gSpellsRect,gSrcRect,					gGuildRect,gHealerRect,gdungeonRect, gStatsRect, gPartyInfoRect,					gUseRect,gPanicRect, gMoveRect, gDungDispRect, gActionRect,gConsoleRect, 					gMScreenRect,leftRect,centerRect,rightRect,cLeftRect,cCenterRect,cRightRect,					doorRect,clwallRect,crwallRect,cRect, gChestRect,gItemRect,gListStatsRect,					gListItemsRect, gCompassRect,gTreasureRect;extern	PicHandle	gThePicture, gConsolePicture, gDungeon1, gLeftWall, gCenterWall, gRightWall,					gLeftDoor,gRightDoor,gFlatWall,gFlatDoor,gOpenSpace,gFarWall,gFarDoor,gCLWall,gCRWall,					gCOpenSpace,gCLDoor,gCRDoor,gCFWall,gCFDoor, gMScreenPicture;extern	CIconHandle	gVialIcon,gShieldIcon, gRingIcon, gSphereIcon,gFlailIcon,gCloakIcon,gArrowIcon,gDaggerIcon,					gSwordIcon,gHelmetIcon,gTorchIcon,gBookIcon,gGlovesIcon,gBurnedIcon,gArmorIcon,					gChestIcon, gCompassIcon,gCNorthIcon,gCSouthIcon,gCEastIcon,					gCWestIcon;extern int			gSndOn,gPanicOn, gInCastle, gPartyNum,gNewChar, gSndNum, gLastChar, gLight,					gLightSpell,gItemUseScreen, gCurChar, gInPrison,gDialogNum,gDisplay,gDungLevel,gXLoc,gYLoc,					gView,gResistFire,gResistIce,gPartyInvis,gInEncounter,gCureWho,gFoundItems[3],					gCreatType, gCreatureCounter, gCreatHits[10],gLevelCount,dmgType,gTreasure,					gDisarmSpellCast,gCompass,ASave,gMagicItems[4],gSpeed,gCharShields[4],gEvade;extern	long		gStats[6], gDungParty[4],gWhichChar,glastWhen,gPanic;extern	Point		glastWhere;extern	DialogPtr	gCastleDialog;extern	RGBColor	gNameBack, gStatsBack, gSpecName,gNormName,gMessBack,gBlack,gStatsFore;extern	CCrsrHandle	gSpellCursor;extern	SFReply		fileName;extern	struct	CharInfo {	Str255	name;	int		type;	int		race;	int		level;	int		exp;	int		status;	int		hits;	int		dmg;	int		age;	int		str;	int		wis;	int		itl;	int		con;	int		dex;	int		items[7];		int		itemsInUse[7];			/* what items are being used */	int		gold;	int	 	bank;					/* released wizard? */	int		mspells[4],cspells[4];	int		dngLevel, xLoc, yLoc,Pos;	};extern	struct	CharInfo	GameChars[8];						/*  Can store up to 8 chars per game  */extern	struct	ItemInfo {	Str255			name;	unsigned char	type;	unsigned char	status;		/* whether item is in use or not */	unsigned char	instore;	unsigned char	level;	Byte			attrib;	unsigned char	dmg;	unsigned char	def;	unsigned char	con;};extern	struct	ItemInfo	GameItems[101];extern	struct	DungInfo 				{	unsigned int	XY[10][10];		/*  x, y  rooms location */	unsigned int	N[100];			/* 100 rooms w/north walls */	unsigned int	S[100];			/* 100 rooms w/south walls */	unsigned int	E[100];			/* 100 rooms w/east walls */	unsigned int	W[100];			/* 100 rooms w/west walls */	unsigned int	SA[100];};extern	struct	DungInfo	Dungeon[1];	extern struct	CreatureInfo 				/* access database each encounter */{	Str255			name;	unsigned char	type;	unsigned char	status;		/* For use in editor only */	unsigned char	instore;	/* Unused variable */	unsigned char	level;	Byte			attrib;	Byte			dmg;	Byte			def;	Byte			hits;};extern struct	CreatureInfo	GameCreatures[1];/************************ CastleRoller ****************************/CastleRoller(){int				itemType, roller_id, itemHit, z,x, dialogDone = FALSE; Handle			itemHandle;Rect			itemRect;	ControlHandle	control;short			ctlPart;Point			mousePt;  gSndNum=19402;PlaySound(); x=NO;for (z=0;z<=7;z++)							/* open slots? */{	if (GameChars[z].status==99)			/* yes */		{		x=YES;		break;		}}if (x==NO)									/* NO! */	{		ClearMessage();						  			DrawString("\pThere is no more space in the The Castle!");		return;	}	gNewChar=z;		gDialogNum=405;	DoDialog();						GetDItem(gCastleDialog, TEXT_ITEM, &itemType, &itemHandle, &itemRect);		SelIText ( gCastleDialog,TEXT_ITEM,0,32767 );		GetDItem(gCastleDialog, OKAY_ITEM, &itemType, &itemHandle, &itemRect);		PenSize(2,2);				InsetRect(&itemRect, -3,-3);			FrameRoundRect(&itemRect, 16, 16);			PenNormal();			 		RandomRoller();					while (dialogDone == FALSE)	{	ModalDialog(NIL_POINTER, &itemHit);	{					switch (itemHit)			{				case CANCEL_ITEM:					dialogDone = TRUE;								DisposeDialog(gCastleDialog);					SetPort(gGameWindow);					break;				case OKAY_ITEM:				 	SaveStats();   					dialogDone = TRUE;										DisposeDialog(gCastleDialog);										SetPort(gGameWindow);				 	CastleRules();				 						DoRollerDialog();									 	ClearMessage();					 	DrawString(GameChars[gNewChar].name);   					DrawString("\p went to the fabulous Lounge.");					EnableItem(gFileMenu, CLOSE_ITEM);		/* File Menu */    				EnableItem(gFileMenu, SAVE_ITEM);		/* File Menu	*/     				DisableItem(gFileMenu, OPEN_ITEM);		/* File Menu	*/     																			  					break; 				case ROLLER_ITEM: 					TurnOffButton(); 				   	RandomRoller();					break; 	  			case 16: 	  				TurnOffButton();									 					GetDItem(gCastleDialog, 16, &itemType, 						&itemHandle, &itemRect);					SetCtlValue (itemHandle,1);					GameChars[gNewChar].type=0;					break;		 							 	  			case 17:	 	  				TurnOffButton();									 					GetDItem(gCastleDialog, 17, &itemType, 						&itemHandle, &itemRect);					SetCtlValue (itemHandle,1);					GameChars[gNewChar].type=1;					break;	 	  			case 18:	 	  				TurnOffButton();									 					GetDItem(gCastleDialog, 18, &itemType, 						&itemHandle, &itemRect);					SetCtlValue (itemHandle,1);					GameChars[gNewChar].type=2;					break;	 	  			case 19: 	  					TurnOffButton();									 						GetDItem(gCastleDialog, 19, &itemType, 							&itemHandle, &itemRect);						SetCtlValue (itemHandle,1);						GameChars[gNewChar].type=3;					break;		 							 	  			case 20:	 	  					TurnOffButton();									 						GetDItem(gCastleDialog, 20, &itemType, 							&itemHandle, &itemRect);						SetCtlValue (itemHandle,1);						GameChars[gNewChar].type=4;					break;	 	  			case 21:	 	  					TurnOffButton();									 						GetDItem(gCastleDialog, 21, &itemType, 							&itemHandle, &itemRect);						SetCtlValue (itemHandle,1);						GameChars[gNewChar].type=5;					break;															}	}	  }  	/* gPanic=NO;				 used for copybits screen update */}	/************************ TurnOffButton ****************************/	TurnOffButton(){int				itemType;Handle			itemHandle;Rect			itemRect;	ControlHandle	control;int				z;  for (z=16;z<=21;z=z+1)					{		GetDItem(gCastleDialog, z, &itemType, &itemHandle, &itemRect);		SetCtlValue (itemHandle,0);	}  }/********************** DoRollerDialog *****************************/DoRollerDialog(){int			itemType, itemHit,  dialogDone = FALSE; Handle		itemHandle;Rect		itemRect;gDialogNum	=	1000;		DoDialog();		while (dialogDone == FALSE)	{		ModalDialog(NIL_POINTER, &itemHit);			switch (itemHit)			{				case 1:		/* YES */					dialogDone = TRUE;					DisposeDialog(gCastleDialog);					SetPort(gGameWindow);					break;			}	}}/************************ RandomRoller ****************************/	RandomRoller(){int				itemType,zz,zx; 		Handle			itemHandle;Rect			itemRect;Str255			hitsStr;long			xx,yy;ControlHandle	control;	for(zz=0;zz<=5;zz++)		{				yy=Random();					xx=(8+((yy*15)/65536));    	/* no stats higher than 15 */			gStats[zz]=xx;			NumToString(gStats[zz], hitsStr);			GetDItem(gCastleDialog, (10+zz), &itemType, &itemHandle, &itemRect);			SetIText(itemHandle,hitsStr);		 }		 		 /**** race options  ****/		 yy=Random();					 xx=(2+((yy*5)/65536));				GetDItem(gCastleDialog, 22, &itemType, &itemHandle, &itemRect);		  if (xx==0)		  	{				SetIText(itemHandle,"\pOrc");			}		  else if (xx==1)		  	{						  	SetIText(itemHandle,"\pGnome");			}		  		  else if (xx==2)		    {				SetIText(itemHandle,"\pElf");			}		  		  else if (xx==3)		    {				SetIText(itemHandle,"\pDwarf");			}		  else if (xx==4)		   {				SetIText(itemHandle,"\pOgre");			}		  else		  	{		  		xx=5;				SetIText(itemHandle,"\pHuman");					  	}		 GameChars[gNewChar].race=xx;												/* store race */					 /**** type options  ****/	 	 	GetDItem(gCastleDialog, 16, &itemType, &itemHandle, &itemRect);			SetCtlValue(itemHandle,1);	/* default type = Queer */			GameChars[gNewChar].type = 0;			GetDItem(gCastleDialog, 17, &itemType, &control, &itemRect);	  	if (gStats[0]>=12 && gStats[1]>=13 && gStats[5]>=12)					/* Drag Queen */			HiliteControl(control,0);	 		else HiliteControl(control,255);							GetDItem(gCastleDialog, 18, &itemType, &control, &itemRect);		if (gStats[4]>=11)				HiliteControl(control,0);		else HiliteControl(control,255);					GetDItem(gCastleDialog, 19, &itemType, &control, &itemRect);		   if (gStats[3]>=12 && gStats[3]>=12 && 					gStats[4]>=13 && gStats[5]>=12)						HiliteControl(control,0);			else HiliteControl(control,255);		GetDItem(gCastleDialog, 20, &itemType, &control, &itemRect);		   if (gStats[3]>=12)														   		HiliteControl(control,0);			else HiliteControl(control,255);					GetDItem(gCastleDialog, 21, &itemType, &control, &itemRect);	       if (gStats[0]>=12 && gStats[1]>=12 && gStats[2]>=12				&& gStats[4]>=12 && gStats[4]>=12 && gStats[5]>=12)								HiliteControl(control,0);			else HiliteControl(control,255);}/************************ SaveStats ****************************/SaveStats()	{int			itemType, z,x,roller_id, itemHit,  dialogDone = FALSE; Handle		itemHandle;Rect		itemRect;Str255		text;/* 			for (x=0;x<=7;x++)	GameChars[gNewChar].name[x]=0;	 zero out all 7 spots */			GetDItem(gCastleDialog, 4, &itemType, &itemHandle, &itemRect);		 /* get name */	GetIText(itemHandle, text);		for (x=0;x<=7;x++)	GameChars[gNewChar].name[x]=text[x];	/* only read in 10 chars */										GameChars[gNewChar].level = 1;				GameChars[gNewChar].exp   = 1;				GameChars[gNewChar].status = 2;		/* alive & well, 1 = dead,0=permdead */				GameChars[gNewChar].age = gStats[3]+4;				GameChars[gNewChar].hits = gStats[0];					GameChars[gNewChar].dmg=0;				GameChars[gNewChar].str = gStats[1];				GameChars[gNewChar].con = gStats[2];				GameChars[gNewChar].wis = gStats[3];				GameChars[gNewChar].itl = gStats[4];				GameChars[gNewChar].dex = gStats[5];				GameChars[gNewChar].gold= ((GameChars[gNewChar].con*3)+25); 				GameChars[gNewChar].bank = 0;				for (x=0;x<=3;x++)							/* zero out all spells */				{					GameChars[gNewChar].mspells[x] = 0;					GameChars[gNewChar].cspells[x] = 0;					}		if (GameChars[gNewChar].type==2)					/* mage */							GameChars[gNewChar].mspells[0] = 1;			else if (GameChars[gNewChar].type==3)				/* wizard */			GameChars[gNewChar].mspells[0] = 1;		else if (GameChars[gNewChar].type==4)				/* priest */			GameChars[gNewChar].cspells[0] = 1;		else if (GameChars[gNewChar].type==5)				/* master */			{			GameChars[gNewChar].mspells[0] = 1;			GameChars[gNewChar].cspells[0] = 1;				}											GameChars[gNewChar].dngLevel=-1;			/* -1 = in Castle */				GameChars[gNewChar].xLoc=0;				GameChars[gNewChar].yLoc=0;				GameChars[gNewChar].Pos=-1;					/* in Castle */							for (z=0;z<=6;z++)				{				GameChars[gNewChar].itemsInUse[z]=OPENSLOT;				GameChars[gNewChar].items[z]=OPENSLOT;				}}/************************ CastleRules ****************************/CastleRules(){long			xx,yy;Str255			text;NumToString(GameChars[gNewChar].gold,text);  yy=Random();  xx=(2+(yy*5)/65536);    	/* random number generator */  	if (xx==0)			ParamText(GameChars[gNewChar].name,text, "\pno spitting allowed in the passageways.","\p ");	else if (xx==1)			ParamText(GameChars[gNewChar].name,text, "\pno feeding the dragons.","\p ");	else if (xx==2)			ParamText(GameChars[gNewChar].name,text, "\pvisit the Castle Shoppes for great bargains!","\p ");	else if (xx==3)			ParamText(GameChars[gNewChar].name,text, "\pbe kind to all creatures.","\p ");	else 		    ParamText(GameChars[gNewChar].name, text, "\pcareful with sharp objects.","\p ");  	}