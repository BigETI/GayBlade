/****************************************                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /***********************************        GayBlade   Ver 1.0.0      ****           ENCOUNTER MODULE          ****      © Copyright by Ryan Best 1992  ****          All Rights Reserved.       *******************************************/#include "GB.h"extern	WindowPtr	gPictureWindow, gGameWindow, gCastleWindow;extern	Boolean		gDone, gWNEImplemented;extern	EventRecord	gTheEvent;extern	MenuHandle	gAppleMenu,gFileMenu,gOptionsMenu,gSpecialMenu;extern	Rect		gIntroRect, gTavernRect, gBankRect, gRollerRect, gStoreRect, gCharRect0,					gCharRect1, gCharRect2, gCharRect3,gItemsRect, gMapRect, gSpellsRect,gSrcRect,					gGuildRect,gHealerRect,gdungeonRect, gStatsRect, gPartyInfoRect,					gUseRect,gPanicRect, gMoveRect, gDungDispRect, gActionRect,gConsoleRect, 					gMScreenRect,leftRect,centerRect,rightRect,cLeftRect,cCenterRect,cRightRect,					doorRect,clwallRect,crwallRect,cRect, gChestRect,gItemRect,gListStatsRect,					gListItemsRect, gCompassRect,gTreasureRect;extern	PicHandle	gThePicture, gConsolePicture, gDungeon1, gLeftWall, gCenterWall, gRightWall,					gLeftDoor,gRightDoor,gFlatWall,gFlatDoor,gOpenSpace,gFarWall,gFarDoor,gCLWall,gCRWall,					gCOpenSpace,gCLDoor,gCRDoor,gCFWall,gCFDoor, gMScreenPicture;extern	CIconHandle	gVialIcon,gShieldIcon, gRingIcon, gSphereIcon,gFlailIcon,gCloakIcon,gArrowIcon,gDaggerIcon,					gSwordIcon,gHelmetIcon,gTorchIcon,gBookIcon,gGlovesIcon,gBurnedIcon,gArmorIcon,					gChestIcon, gCompassIcon,gCNorthIcon,gCSouthIcon,gCEastIcon,					gCWestIcon;extern int			gSndOn,gPanicOn, gInCastle, gPartyNum,gNewChar, gSndNum, gLastChar, gLight,					gLightSpell,gItemUseScreen, gCurChar, gInPrison,gDialogNum,gDisplay,gDungLevel,gXLoc,gYLoc,					gView,gResistFire,gResistIce,gPartyInvis,gInEncounter,gCureWho,gFoundItems[3],					gCreatType, gCreatureCounter, gCreatHits[10],gLevelCount,dmgType,gTreasure,					gDisarmSpellCast,gCompass,ASave,gMagicItems[4],gSpeed,gCharShields[4],gEvade,					gItemsOnFloor,gCPUSpeed;extern	long		gStats[6], gDungParty[4],gWhichChar,glastWhen,gPanic;extern	Point		glastWhere;extern	DialogPtr	gCastleDialog;extern	RGBColor	gNameBack, gStatsBack, gSpecName,gNormName,gMessBack,gBlack,gStatsFore;extern	CCrsrHandle	gSpellCursor;extern	SFReply		fileName;extern	Rect			GlobalDestRect,GlobalSourceRect;/* Temporary rect used for the pict & gworld. */ extern	CGrafPtr		GlobalCurrentPort;				/* Port used before switching to the gworld's. */extern	GDHandle		GlobalCurrentDevice;			/* GDevice used before switching to the gworld's. */extern	GWorldPtr		GlobalGWorld;					/* Pointer to Gworld */extern	PixMapHandle	GlobalPixMap;					/* Needed PixMapHandle to lock down.*/		extern	struct	CharInfo {	Str255	name;	int		type;	int		race;	int		level;	int		exp;	int		status;	int		hits;	int		dmg;	int		age;	int		str;	int		wis;	int		itl;	int		con;	int		dex;	int		items[7];		int		itemsInUse[7];			/* what items are being used */	int		gold;	int	 	bank;					/* released wizard? */	int		mspells[4],cspells[4];	int		dngLevel, xLoc, yLoc,Pos;	};extern	struct	CharInfo	GameChars[8];						/*  Can store up to 8 chars per game  */extern	struct	ItemInfo {	Str255			name;	unsigned char	type;	unsigned char	status;		/* whether item is in use or not */	unsigned char	instore;	unsigned char	level;	Byte			attrib;	unsigned char	dmg;	unsigned char	def;	unsigned char	con;};extern	struct	ItemInfo	GameItems[101];extern	struct	DungInfo 				{	unsigned int	XY[10][10];		/*  x, y  rooms location */	unsigned int	N[100];			/* 100 rooms w/north walls */	unsigned int	S[100];			/* 100 rooms w/south walls */	unsigned int	E[100];			/* 100 rooms w/east walls */	unsigned int	W[100];			/* 100 rooms w/west walls */	unsigned int	SA[100];};extern	struct	DungInfo	Dungeon[1];	extern struct	CreatureInfo 				/* access database each encounter */{	Str255			name;	unsigned char	type;	unsigned char	status;		/* For use in editor only */	unsigned char	instore;	/* Unused variable */	unsigned char	level;	Byte			attrib;	Byte			dmg;	Byte			def;	Byte			hits;};extern struct	CreatureInfo	GameCreatures[1];/******************************* CheckForEncounter **************************************/CheckForEncounter()				/*** Checks if encounter is hit ***/		 {long		yy;					/* random number variable */unsigned	min,max;min=0;max=100;					/** set range **/ yy=GetRandomNum(min,max);		/** get random number */if (yy<=6 || Dungeon[gDungLevel].SA[Dungeon[gDungLevel].XY[gXLoc][gYLoc]]==249)		InitEncounter();			/* YES! hit encounter! */else	return;}/******************************* InitEncounter **************************************/InitEncounter()				  /*** SET-UP ENCOUNTER ROUTINE ***/		 {int			x,z,theCreature;  /* creature rec#, hits per creature */Str255		theText;unsigned	min,max;long		y;gItemsOnFloor=NO;			/* used for random creature checking */gInEncounter=YES;			/* toggle variable to YES */gEvade=NO;					/* party has not evaded yet */for (z=0;z<=3;z++)			/* Init. shielding array */	gCharShields[z]=99;		/* char shields in enc.set to 99 */min=gLevelCount*8;			/* set monster record based on level */max=8+(gLevelCount*8);		/* maximum monster level */if (Dungeon[gDungLevel].SA[Dungeon[gDungLevel].XY[gXLoc][gYLoc]]==249)	theCreature=103;		/* defenders */else	{	y=GetRandomNum(min,max);	theCreature=y;			/* set creature now */	}	GetCreature(theCreature);	/* GET CREATURE FROM DATABASE */							/* get it first, then do below */AnimateCreature();			/* go animate it now */	min=1;max=9;			/* max of 9 characters */	y=GetRandomNum(min,max);	gCreatureCounter=y;			/* count total creatures */ClearMessage();	DrawString("\pYou have encountered ");		NumToString(gCreatureCounter,theText);			RGBForeColor(&gSpecName);				DrawString(theText);				DrawString("\p ");									 	DrawString(GameCreatures[0].name);			if (y==1)							/** if only one creature **/		 		DrawString("\p!");		 	else		 		DrawString("\ps!");			/** if more than one creatures **/	Pause();		 			RGBForeColor(&gNormName);	Pause();if (gPartyInvis==ON && GameCreatures[0].attrib==0){	gInEncounter=NO;	UpdateDV();	ClearMessage();	return;									/* if invis on & low level creat, leave */}for (x=0;x<=gCreatureCounter;x++)			/* gCreatureCounter= # of creatures */	gCreatHits[x]=GameCreatures[0].hits;	/* TAKE FROM CREATURE DATABASE! */EncounterLoop();							/* go to encounter loop */AutoSave();									/* now save after each encounter */}/*************************** EncounterLoop ******************************/EncounterLoop()				/* after InitEncounter has been done **/{int			myTurn,z,x,y,keepGoing=YES;unsigned	min,max;Str255		theText;min=0;max=100;					/* 65& chance party goes first */myTurn=GetRandomNum(min,max); 		if (myTurn<=65)				/* Who goes first?? */		myTurn=YES;				/* dungeon party first! */	else		myTurn=NO;				/* creature's turn first! */			while (keepGoing!=NO)		/********** THE LOOP **********/	{	if (myTurn==YES)		{			keepGoing=PartyTurn();	/* parties's turn */				if (CheckPartyStatus()==YES) /* ALL DEAD? */					return;				if (keepGoing==NO)	/* keepGoing=if creatures left, etc. */					{					if (gEvade==YES)						break;					CreatureDeath2();					break;					}			myTurn=NO;				/* toggle to CREATURE */		}	else							/* creature's turn */			{							CreatureTurn();			if (CheckPartyStatus()==YES) /* ALL DEAD? */				return;			else				myTurn=YES;				/* toggle to PARTY */			for (z=0;z<=3;z++)			/* Re-init. shielding array */				gCharShields[z]=99;		/* char shields in enc.set to false */						}	}	gInEncounter=NO;					/* finished with encounter */ClearMessage();if (gLight==ON && gEvade == NO || 	gLightSpell==ON && gEvade == NO)	/* check for treas. if light is on */	CheckForTreasure();				/* now check treasure! */	/**** NOW CHECK TORCHES ******/gLight=OFF;	  for (x=0;x<=gPartyNum;x++)		/* check each char */	  {	  	for (y=0;y<=6;y++)				/* check each item */	  		{	  			if (GameItems[GameChars[gDungParty[x]].itemsInUse[y]].type==TORCH	  				|| gLightSpell==ON)						gLight=ON;		/* turn light ON */			}	  }	UpdateDV();}/******************** CreatureTurn ************************************/CreatureTurn(){int			z,y,keepGoing;Str255		theText;unsigned	min,max;AnimateCreature();	for (z=1;z<=gCreatureCounter;z++)				/** creature counter=#left */		{     		if (GameCreatures[0].attrib==0)			/** limited to fighting only **/				CreatureFights();		else if (GameCreatures[0].attrib==1)	/** limited to poison & fighting **/			{			y=GetRandomNum(min=0,max=10);		/* 10% chance of poisoning */						if (y==0)					CreaturePoisons();				else					CreatureFights();			}		else if (GameCreatures[0].attrib==2)	/** limited to breathing & fighting **/			{			y=GetRandomNum(min=0,max=10);		/* 10% chance of fire breath */						if (y==0)					CreatureBreathes();				else					CreatureFights();			}		else if (GameCreatures[0].attrib==3)	/** limited to MAGIC & fighting **/			{			y=GetRandomNum(min=0,max=20);		/* 25% chance of cleric spell */						if (y<=5)					CreatureMagic();				else					CreatureFights();			}					else if (GameCreatures[0].attrib==4)	/** limited to CLERIC & fighting **/			{			y=GetRandomNum(min=0,max=20);		/* 10% chance of cleric spell */						if (y<=1)					CreatureCleric();				else					CreatureFights();			}		else if (GameCreatures[0].attrib==5)	/** limited to CLERIC & Magic **/			{			y=GetRandomNum(min=0,max=40);		/* 8% chance of cleric spell */						if (y<=3)					CreatureCleric();				else if (y>=4 && y<=6)			/* 13% chance of magic spell */							CreatureMagic();									else					CreatureFights();			}								else if (GameCreatures[0].attrib==7)	/** limited to draining & fighting **/			{			y=GetRandomNum(min=0,max=30);		/* 17% chance of draining */						if (y<=4)					CreatureDrains();				else					CreatureFights();			}					else if (GameCreatures[0].attrib==6)	/** limited to icing & fighting **/			{			y=GetRandomNum(min=0,max=20);		/* 8% chance of ice storm */						if (y<=2)					CreatureIces();				else					CreatureFights();			}								CheckPartyDamage();		  if (CheckPartyStatus()==YES)	 		/* ALL DEAD? */				return;								/* yes, then return */					PauseAnim();		/* this pauses between dmg messages for a moment */		PauseAnim();		/* this pauses between dmg messages for a moment */		PauseAnim();		/* this pauses between dmg messages for a moment */									}}/******************** CreatureCleric ***********************************/CreatureCleric(){int			z,y,fx,dmg,theChar,keepGoing;Str255		theText;Byte		totDamage;unsigned	min,max;CIconHandle		animIcon;Rect			fbRect,destRect,worldBounds;GWorldPtr		world;GWorldPtr		MakeGWorld();/*** which char killed? ***/min=0;max=gPartyNum+1;						/* add 1 to max for rnd# processing */theChar=GetRandomNum(min,max);				/* random char hit */if (GameChars[gDungParty[theChar]].status >= 2 && 	GameChars[gDungParty[theChar]].status != 99 )	{		ClearMessage();						/* eye of death sound */		gSndNum=29924;		PlaySound();		ClearMessage();		DrawString(GameCreatures[0].name);		DrawString("\p casts Eye of Death!");		Pause();Pause();				RGBForeColor(white);RGBBackColor(black);	SetRect(&worldBounds,33,33,364,299);						SetRect(&destRect,33,33,364,299);			world=MakeGWorld(&worldBounds);	SetRect(&gMScreenRect,0,0,331,266);				CopyIntroBits(world,&gMScreenRect);			/* copy mRect screen */		animIcon=GetCIcon(198);			for (fx=0;fx<=3;fx++)			{				SetRect(&fbRect,149-(4*fx),140-(4*fx),213+(4*fx),204+(4*fx));							PlotCIcon(&fbRect,animIcon);				RGBForeColor(white);				RGBBackColor(black);   		 		CopyWorldBits(world,&gMScreenRect);		/* Update console screen */			}						SetRect(&fbRect,96,140,257,257);						PlotCIcon(&fbRect,animIcon);				CopyWorldBits(world,&gMScreenRect);		/* Update console screen */	SetRect(&gMScreenRect,33,33,331,266);		/* double check rect */			DisposeCIcon(animIcon);		DisposeGWorld(world); 					GameChars[gDungParty[theChar]].status=DEAD;		ClearMessage();			DrawString(GameChars[gDungParty[theChar]].name);			GameChars[gDungParty[theChar]].dmg++;				DrawString("\p has been killed!");		DeadChar();		Pause();	}}/******************** CreaturePoisons ***********************************/CreaturePoisons(){int				z,y,dmg,fx,theChar,keepGoing;Str255			theText;Byte			totDamage;unsigned		min,max;CIconHandle		animIcon;Rect			fbRect,destRect,worldBounds;GWorldPtr		world;GWorldPtr		MakeGWorld();/*** which char poisoned? ***/min=0;max=gPartyNum+1;						/* add 1 to max for rnd# processing */theChar=GetRandomNum(min,max);				/* random char hit */	RGBForeColor(white);RGBBackColor(black);	SetRect(&worldBounds,33,33,364,299);						SetRect(&destRect,33,33,364,299);			world=MakeGWorld(&worldBounds);	SetRect(&gMScreenRect,0,0,331,266);				CopyIntroBits(world,&gMScreenRect);			/* copy mRect screen */		animIcon=GetCIcon(200);	 		gSndNum=16878; 		 				PlaySound();				for (fx=0;fx<=3;fx++)			{				SetRect(&fbRect,149-(4*fx),140-(4*fx),213+(4*fx),204+(4*fx));							PlotCIcon(&fbRect,animIcon);				RGBForeColor(white);				RGBBackColor(black);   		 		CopyWorldBits(world,&gMScreenRect);		/* Update console screen */			}						SetRect(&fbRect,96,140,257,257);						PlotCIcon(&fbRect,animIcon);				CopyWorldBits(world,&gMScreenRect);		/* Update console screen */	SetRect(&gMScreenRect,33,33,331,266);		/* double check rect */if (GameChars[gDungParty[theChar]].status >= 2 && 	GameChars[gDungParty[theChar]].status != 99 )	{		GameChars[gDungParty[theChar]].status=POISONED;		ClearMessage();			DrawString(GameChars[gDungParty[theChar]].name);			GameChars[gDungParty[theChar]].dmg++;				DrawString("\p has been poisoned!");		}		DisposeCIcon(animIcon);	DisposeGWorld(world);}/******************** CreatureDrains ***********************************/CreatureDrains(){int			z,y,dmg,theChar,keepGoing;Str255		theText;Byte		totDamage;unsigned	min,max;/*** which char drained? ***/min=0;max=gPartyNum+1;						/* add 1 to max for rnd# processing */theChar=GetRandomNum(min,max);				/* random char hit */if (GameChars[gDungParty[theChar]].status >= 2 && 	GameChars[gDungParty[theChar]].status != 99 )	{		GameChars[gDungParty[theChar]].level--;			ClearMessage();			DrawString(GameChars[gDungParty[theChar]].name);		DrawString("\p has been drained a level!"); 		gSndNum=22699; 		 				PlaySound();				Pause();		if (GameChars[gDungParty[theChar]].level<=0)			{			gSndNum=30601; 		 					PlaySound();				ClearMessage();			GameChars[gDungParty[theChar]].status=DEAD;			DrawString(GameChars[gDungParty[theChar]].name);			DrawString("\p has died!");			DeadChar();			/* sort party */			Pause();							}		}}/******************** CreatureBreathes ***********************************/CreatureBreathes(){int				z,y,fx,dmg,theChar,keepGoing;Str255			theText;Byte			totDamage;unsigned		min,max;CIconHandle		animIcon;Rect			fbRect,destRect,worldBounds;GWorldPtr		world;GWorldPtr		MakeGWorld(); 	gSndNum=15447; 		 				PlaySound();			ClearMessage();DrawString("\pThe "); 	DrawString(GameCreatures[0].name);	DrawString("\p breathes fire!"); gPanic=NO;									/* for copybits routine */			RGBForeColor(white);RGBBackColor(black);	SetRect(&worldBounds,33,33,364,299);						SetRect(&destRect,33,33,364,299);			world=MakeGWorld(&worldBounds);	SetRect(&gMScreenRect,0,0,331,266);				CopyIntroBits(world,&gMScreenRect);			/* copy mRect screen */		animIcon=GetCIcon(193);			for (fx=0;fx<=3;fx++)			{				SetRect(&fbRect,149-(4*fx),140-(4*fx),213+(4*fx),204+(4*fx));							PlotCIcon(&fbRect,animIcon);				RGBForeColor(white);				RGBBackColor(black);   		 		CopyWorldBits(world,&gMScreenRect);		/* Update console screen */			}						SetRect(&fbRect,96,140,257,257);						PlotCIcon(&fbRect,animIcon);				CopyWorldBits(world,&gMScreenRect);		/* Update console screen */	SetRect(&gMScreenRect,33,33,331,266);		/* double check rect */				/*** which char hit? ***/min=0;max=gPartyNum+1;						/* add 1 to max for rnd# processing */theChar=GetRandomNum(min,max);				/* random char hit */    dmg=GetRandomNum(min=GameCreatures[0].dmg,max=GameCreatures[0].dmg*2);	/* total can breath for */    	totDamage=CalcDamage(dmg,theChar);		/* Calc. tot. damage of hit */		if (gResistFire==ON)			totDamage=totDamage-(totDamage*.20);	/* 20% off */	if (totDamage>0 && GameChars[gDungParty[theChar]].status>=2 &&		GameChars[gDungParty[theChar]].status<=99)								/* char is hit! */	{	if (GameChars[gDungParty[theChar]].dmg+totDamage>=		GameChars[gDungParty[theChar]].hits)		{			GameChars[gDungParty[theChar]].status=DEAD;			ClearMessage();			DrawString(GameChars[gDungParty[theChar]].name);			DrawString("\p has been toasted!");			Pause();Pause();				DeadChar();		}	else		{    	GameChars[gDungParty[theChar]].dmg=    		GameChars[gDungParty[theChar]].dmg+totDamage;					ClearMessage();						DrawString(GameChars[gDungParty[theChar]].name);							NumToString(totDamage,theText);							DrawString("\p was burnt for ");							DrawString(theText);						DrawString("\p hits!");					Pause();Pause();		}	}	DisposeCIcon(animIcon);	DisposeGWorld(world);	}/******************** CreatureIces ***********************************/CreatureIces(){int			z,y,x,fx,dmg,theChar,keepGoing;Str255		theText;Byte		totDamage;unsigned	min,max;CIconHandle		animIcon;Rect			fbRect,destRect,worldBounds;GWorldPtr		world;GWorldPtr		MakeGWorld();		 	gSndNum=15447; 		 				PlaySound();					ClearMessage();DrawString("\pThe "); 	DrawString(GameCreatures[0].name);	DrawString("\p hurles shards of ice!"); gPanic=NO;									/* for copybits routine */			RGBForeColor(white);RGBBackColor(black);	SetRect(&worldBounds,33,33,364,299);						SetRect(&destRect,33,33,364,299);			world=MakeGWorld(&worldBounds);	SetRect(&gMScreenRect,0,0,331,266);				CopyIntroBits(world,&gMScreenRect);			/* copy mRect screen */		animIcon=GetCIcon(197);			for (fx=0;fx<=3;fx++)			{				SetRect(&fbRect,149-(4*fx),140-(4*fx),213+(4*fx),204+(4*fx));							PlotCIcon(&fbRect,animIcon);				RGBForeColor(white);				RGBBackColor(black);   		 		CopyWorldBits(world,&gMScreenRect);		/* Update console screen */			}						SetRect(&fbRect,96,140,257,257);						PlotCIcon(&fbRect,animIcon);				CopyWorldBits(world,&gMScreenRect);		/* Update console screen */	SetRect(&gMScreenRect,33,33,331,266);		/* double check rect *//*** which char hit? ***/for (x=0;x<=gPartyNum;x++)	{    dmg=GetRandomNum(min=GameCreatures[0].dmg,max=GameCreatures[0].dmg*2);	/* total can ice for */		if (gResistIce==ON)			totDamage=dmg-(dmg*.60);		/* 60% off */		else			totDamage=dmg;	if (totDamage>0 && GameChars[gDungParty[x]].status>=2 &&		GameChars[gDungParty[x]].status<=99)								/* char is hit! */	{	if (GameChars[gDungParty[x]].dmg+totDamage>=		GameChars[gDungParty[x]].hits)		{			GameChars[gDungParty[x]].status=DEAD;			ClearMessage();			DrawString(GameChars[gDungParty[x]].name);			DrawString("\p has been iced dead!");			Pause();Pause();				DeadChar();		}	else		{    	GameChars[gDungParty[x]].dmg=    		GameChars[gDungParty[x]].dmg+totDamage;					ClearMessage();						DrawString(GameChars[gDungParty[x]].name);							NumToString(totDamage,theText);							DrawString("\p was frozen for ");							DrawString(theText);						DrawString("\p hits!");					Pause();		}	}  }  	DisposeCIcon(animIcon);	DisposeGWorld(world);}/******************** CreatureMagic ***********************************/CreatureMagic(){int			z,x,y,fx,dmg,theChar,keepGoing;Str255		theText;Byte		totDamage;unsigned	min,max;CIconHandle		animIcon;Rect			fbRect,destRect,worldBounds;GWorldPtr		world;GWorldPtr		MakeGWorld();/*** which spell? ***/z=GetRandomNum(min=0,max=4);if (z==0)				/* HEAVY WOUND */  {	gSndNum=23536;	 		 	 	 			PlaySound();	ClearMessage();	DrawString(GameCreatures[0].name);	DrawString("\p casts heavy wound!");	Pause();		RGBForeColor(white);RGBBackColor(black);	SetRect(&worldBounds,33,33,364,299);						SetRect(&destRect,33,33,364,299);			world=MakeGWorld(&worldBounds);	SetRect(&gMScreenRect,0,0,331,266);				CopyIntroBits(world,&gMScreenRect);			/* copy mRect screen */		animIcon=GetCIcon(199);			for (fx=0;fx<=3;fx++)			{				SetRect(&fbRect,149-(4*fx),140-(4*fx),213+(4*fx),204+(4*fx));							PlotCIcon(&fbRect,animIcon);				RGBForeColor(white);				RGBBackColor(black);   		 		CopyWorldBits(world,&gMScreenRect);		/* Update console screen */			}						SetRect(&fbRect,96,140,257,257);						PlotCIcon(&fbRect,animIcon);				CopyWorldBits(world,&gMScreenRect);		/* Update console screen */	SetRect(&gMScreenRect,33,33,331,266);		/* double check rect */	for (x=0;x<=gPartyNum;x++)	{	dmg=GetRandomNum(min=1,max=GameCreatures[0].level*4);	/* total creature can hit for */	 totDamage=CalcDamage(dmg,x);		/* now go calc. tot. damage of hit */	if (GameChars[gDungParty[x]].dmg+totDamage>=		GameChars[gDungParty[x]].hits && 		GameChars[gDungParty[x]].status>=2 &&		GameChars[gDungParty[x]].status<=99)		{			GameChars[gDungParty[x]].status=DEAD;			ClearMessage();			DrawString(GameChars[gDungParty[x]].name);			DrawString("\p has been destroyed!");			Pause();Pause();				DeadChar();		}	else		{			if (totDamage<=0)			totDamage=1;				/* creature wounds for at least 1 hit */		    	GameChars[gDungParty[x]].dmg=	    		GameChars[gDungParty[x]].dmg+totDamage;					ClearMessage();						DrawString(GameChars[gDungParty[x]].name);						NumToString(totDamage,theText);						DrawString("\p was wounded for ");				DrawString(theText);				DrawString("\p hits!");							Pause();Pause();		}	} 		DisposeCIcon(animIcon);	DisposeGWorld(world);    }if (z==1)				/* LIGHTNING BOLTS */  {	ClearMessage();	DrawString(GameCreatures[0].name);	DrawString("\p casts lightning bolts!");		gSndNum=16847; 		 				PlaySound();						gPanic=NO;									/* for copybits routine */			RGBForeColor(white);RGBBackColor(black);	SetRect(&worldBounds,33,33,364,299);						SetRect(&destRect,33,33,364,299);			world=MakeGWorld(&worldBounds);	SetRect(&gMScreenRect,0,0,331,266);				CopyIntroBits(world,&gMScreenRect);			/* copy mRect screen */		animIcon=GetCIcon(194);			for (fx=0;fx<=3;fx++)			{				SetRect(&fbRect,149-(4*fx),140-(4*fx),213+(4*fx),204+(4*fx));							PlotCIcon(&fbRect,animIcon);				RGBForeColor(white);				RGBBackColor(black);   		 		CopyWorldBits(world,&gMScreenRect);		/* Update console screen */			}						SetRect(&fbRect,96,140,257,257);						PlotCIcon(&fbRect,animIcon);				CopyWorldBits(world,&gMScreenRect);		/* Update console screen */	SetRect(&gMScreenRect,33,33,331,266);		/* double check rect */	Pause();for (x=0;x<=gPartyNum;x++)	{	dmg=GetRandomNum(min=1,max=GameCreatures[0].level*11);	/* total creature can hit for */	 totDamage=CalcDamage(dmg,x);		/* now go calc. tot. damage of hit */	if (GameChars[gDungParty[x]].dmg+totDamage>=		GameChars[gDungParty[x]].hits && 		GameChars[gDungParty[x]].status>=2 &&		GameChars[gDungParty[x]].status<=99)		{			GameChars[gDungParty[x]].status=DEAD;			ClearMessage();			DrawString(GameChars[gDungParty[x]].name);			DrawString("\p has been zapped dead!");			Pause();Pause();				DeadChar();		}	else			{	    	GameChars[gDungParty[x]].dmg=	    		GameChars[gDungParty[x]].dmg+totDamage;					ClearMessage();						DrawString(GameChars[gDungParty[x]].name);						NumToString(totDamage,theText);						DrawString("\p was zapped for ");				DrawString(theText);				DrawString("\p hits!");			Pause();Pause();		}	} 	  	DisposeCIcon(animIcon);	DisposeGWorld(world);    }if (z==2)				/* ICE STORM */  CreatureIces();if (z==3)				/* FIREBALLS */  {  	gSndNum=8050;		/*	 fireball sound 	*/		PlaySound();		ClearMessage();	DrawString("\pFireballs blaze all over the place!");		Pause();		RGBForeColor(white);RGBBackColor(black);	SetRect(&worldBounds,33,33,364,299);						SetRect(&destRect,33,33,364,299);			world=MakeGWorld(&worldBounds);	SetRect(&gMScreenRect,0,0,331,266);				CopyIntroBits(world,&gMScreenRect);			/* copy mRect screen */		animIcon=GetCIcon(193);			for (fx=0;fx<=3;fx++)			{				SetRect(&fbRect,149-(4*fx),140-(4*fx),213+(4*fx),204+(4*fx));							PlotCIcon(&fbRect,animIcon);				RGBForeColor(white);				RGBBackColor(black);   		 		CopyWorldBits(world,&gMScreenRect);		/* Update console screen */			}						SetRect(&fbRect,96,140,257,257);						PlotCIcon(&fbRect,animIcon);				CopyWorldBits(world,&gMScreenRect);		/* Update console screen */	SetRect(&gMScreenRect,33,33,331,266);		/* double check rect */			DisposeCIcon(animIcon);		DisposeGWorld(world);  		for (x=0;x<=gPartyNum;x++)	{ClearMessage();					dmg=GetRandomNum(min=1,max=GameCreatures[0].level*8);	/* total creature can hit for */	 totDamage=CalcDamage(dmg,x);		/* now go calc. tot. damage of hit */	if (totDamage>0 && GameChars[gDungParty[theChar]].status>=2 &&		GameChars[gDungParty[x]].status<=99)			/* char is hit! */	{	if (GameChars[gDungParty[x]].dmg+totDamage>=		GameChars[gDungParty[x]].hits)		{			GameChars[gDungParty[x]].status=DEAD;			ClearMessage();			DrawString(GameChars[gDungParty[x]].name);			DrawString("\p has been toasted!");			Pause();Pause();				DeadChar();		}	else			{		    	GameChars[gDungParty[x]].dmg=	    		GameChars[gDungParty[x]].dmg+totDamage;					ClearMessage();						DrawString(GameChars[gDungParty[x]].name);						NumToString(totDamage,theText);						DrawString("\p was burnt for ");				DrawString(theText);				DrawString("\p hits!");			Pause();Pause();		}   	}	  }         }}/******************** CreatureFights ***********************************/CreatureFights(){int			z,y,x,dmg,theChar,keepGoing;Str255		theText;Byte		totDamage;unsigned	min,max;y=GetRandomNum(min=0,max=5);				/* creature does not swing */	if (y==1)		return;/*** which char hit? ***/min=0;max=gPartyNum+1;						/* add 1 to max for rnd# processing */theChar=GetRandomNum(min,max);				/* random char hit */for (x=0;x<=gPartyNum;x++)		/* search through array for shielded char */{if (gCharShields[x]==theChar)	/* 60% chance saved by shield */	{	if (GetRandomNum(min=0,max=100)<=60)		{			ClearMessage();			DrawString(GameChars[theChar].name);			DrawString("\p was protected by parrying!");					Pause();			return;		}	}	}	    dmg=GetRandomNum(min=1,max=GameCreatures[0].dmg);	/* total creature can hit for */    	totDamage=CalcDamage(dmg,theChar);	/* now go calc. tot. damage of hit */	if (totDamage>0)						/* char is hit! */	{		    	GameChars[gDungParty[theChar]].dmg=    		GameChars[gDungParty[theChar]].dmg+totDamage;					ClearMessage();						DrawString(GameChars[gDungParty[theChar]].name);							NumToString(totDamage,theText);							DrawString("\p received ");							DrawString(theText);						if (totDamage==1)							DrawString("\p hit!");						else														DrawString("\p hits!");					Pause();	}}/******************** PartyTurn ************************************/PartyTurn(){char			theChar;GrafPtr			oldPort;Rect			itemRect,destRect,worldBounds;int				theTime,z=FALSE, x, y,count=-1,keepGoing=YES;Str255			theText;long			secs;Point			mouseLoc;	FlushEvents (everyEvent, REMOVE_ALL_EVENTS);	/* clear events before going to loop */   for (x=0;x<=gPartyNum;x++)						/* let all chars have a chance */  {   z=FALSE;    if (GameChars[gDungParty[x]].status>=2 &&	/* if char exists & alive */    	GameChars[gDungParty[x]].status!=99)       {		ClearMessage();		NumToString(gCreatureCounter,theText);			RGBForeColor(&gSpecName);				DrawString("\p[");					DrawString(theText);					DrawString("\p ");		 	DrawString(GameCreatures[0].name);			if (gCreatureCounter>=2)		/** if only one creature **/		 		DrawString("\ps");			/** if more than one creatures **/								DrawString("\p ] ");							RGBForeColor(&gNormName);		DrawString(GameChars[gDungParty[x]].name);		DrawString("\p's turn:");			gCurChar=gDungParty[x];			gWhichChar=x;			ReplotChar();secs=Time+8;					while (z!=TRUE)						/* give each char a chance */		  {		  	if (Time==secs)					/* 6 seconds per char */				break;			if (gWNEImplemented)				WaitNextEvent(everyEvent,&gTheEvent,MIN_SLEEP,NIL_MOUSE_REGION);			else				{					SystemTask();					SndTask();					GetNextEvent(everyEvent, &gTheEvent);				}						switch (gTheEvent.what)		{	 	case updateEvt:							  			GetPort(&oldPort);		 			 				SetPort((WindowPtr)gTheEvent.message);				BeginUpdate((WindowPtr)gTheEvent.message);				if (gPanic==NO)							{					DrawPicture (gConsolePicture,&gConsoleRect);					if (gInCastle==YES) 						DrawPicture (gMScreenPicture, &gMScreenRect); 					else if (gInCastle==NO && gPanic==NO)						UpdateDV();					UpdateAll();					AnimateCreature();						}					gPanic=NO;				EndUpdate((WindowPtr)gTheEvent.message); 			SetPort(oldPort); 				break;	 	case app4Evt:	 		if (gTheEvent.message & 0x00000001)	/* resume from multi-finder */	 			{					DrawPicture (gConsolePicture,&gConsoleRect);					if (gInCastle==YES) 						DrawPicture (gMScreenPicture, &gMScreenRect); 					else if (gInCastle==NO)						UpdateDV();					UpdateAll();					AnimateCreature();					}			break;	 	  							case mouseDown:			/* only look for mousedown event */					GetMouse(&mouseLoc);			if (PtInRect(mouseLoc, &gPanicRect))					Panic();			else if (PtInRect(mouseLoc, &gPartyInfoRect))					PartyInfo();							else if (PtInRect(mouseLoc, &gStatsRect))				{					Items();					z=TRUE;				}			else if (PtInRect(mouseLoc, &gMScreenRect))				TreasureRoutines();			else if (PtInRect(mouseLoc, &gListStatsRect) &&				gDungParty[0] != 99)				{					UpdateStats();					gDisplay=1;				}							else if (PtInRect(mouseLoc, &gListItemsRect) &&				gDungParty[0] != 99)				{					ListItems();					gDisplay=0;				}													else if (PtInRect(mouseLoc, &gActionRect))				{		  			UserAction(mouseLoc);				  	z=TRUE;				/* go on to next char */				}							break;			}		  	}   }   	if (gCreatureCounter<=0)		/* creature dead */  		 return(keepGoing=NO);		/** stop **/	  	if (gInCastle==YES)				/* if teleported from encounter, */  		 return;					/* just return...*/ } return(keepGoing=YES);	 }/************************ AnimateCreature*********************/AnimateCreature(){CIconHandle	creature1, creature2, creature3,creature4,			creature5, creature6;Rect		creatureRect1,creatureRect2, creatureRect3, destRect,creatureRect4,			worldBounds,creatureRect5, creatureRect6;int			x;GWorldPtr		world;GWorldPtr		MakeGWorld();unsigned		min,max; RGBForeColor(white);RGBBackColor(black);	PlayCreatureSound();if (GameCreatures[0].type==4)		/* humanoid */{	SetRect(&creatureRect1,146,120,210,184);	SetRect(&creatureRect2,146,184,210,248);		creature1=GetCIcon(137);		creature2=GetCIcon(138);			PlotCIcon(&creatureRect1,creature1);			PlotCIcon(&creatureRect2,creature2);		DisposeCIcon(creature1);		DisposeCIcon(creature2);	creature1=GetCIcon(169);	creature2=GetCIcon(170);PauseAnim();	PauseAnim();	PauseAnim();				PlotCIcon(&creatureRect1,creature1);		PlotCIcon(&creatureRect2,creature2);				Pause();	DisposeCIcon(creature1);	DisposeCIcon(creature2);		creature1=GetCIcon(137);		creature2=GetCIcon(138);PauseAnim();	PauseAnim();	PauseAnim();				PlotCIcon(&creatureRect1,creature1);			PlotCIcon(&creatureRect2,creature2);		DisposeCIcon(creature1);		DisposeCIcon(creature2);	}else if (GameCreatures[0].type==9)		/* humanoid2 */{	SetRect(&creatureRect1,146,120,210,184);	SetRect(&creatureRect2,146,184,210,248);		creature1=GetCIcon(188);		creature2=GetCIcon(189);			PlotCIcon(&creatureRect1,creature1);			PlotCIcon(&creatureRect2,creature2);		DisposeCIcon(creature1);		DisposeCIcon(creature2);	creature1=GetCIcon(190);	creature2=GetCIcon(191);PauseAnim();	PauseAnim();	PauseAnim();			PlotCIcon(&creatureRect1,creature1);		PlotCIcon(&creatureRect2,creature2);	DisposeCIcon(creature1);	DisposeCIcon(creature2);			Pause();		creature1=GetCIcon(188);		creature2=GetCIcon(189);PauseAnim();	PauseAnim();	PauseAnim();				PlotCIcon(&creatureRect1,creature1);			PlotCIcon(&creatureRect2,creature2);		DisposeCIcon(creature1);		DisposeCIcon(creature2);		creature1=GetCIcon(190);	creature2=GetCIcon(191);PauseAnim();	PauseAnim();	PauseAnim();			PlotCIcon(&creatureRect1,creature1);		PlotCIcon(&creatureRect2,creature2);	DisposeCIcon(creature1);	DisposeCIcon(creature2);	}else if (GameCreatures[0].type==7)		/* m/c caster */{for (x=0;x<=1;x++)	{	SetRect(&creatureRect1,146,120,210,184);	SetRect(&creatureRect2,146,184,210,248);		creature1=GetCIcon(174);		creature2=GetCIcon(175);PauseAnim();	PauseAnim();						PlotCIcon(&creatureRect1,creature1);			PlotCIcon(&creatureRect2,creature2);		DisposeCIcon(creature1);		DisposeCIcon(creature2);		creature1=GetCIcon(181);PauseAnim();	PauseAnim();						PlotCIcon(&creatureRect1,creature1);		DisposeCIcon(creature1);PauseAnim();	PauseAnim();				}													}else if (GameCreatures[0].type==11)		/* Defender */{for (x=0;x<=2;x++)	{	SetRect(&creatureRect1,146,120,210,184);	SetRect(&creatureRect2,146,184,210,248);		creature1=GetCIcon(176);		creature2=GetCIcon(178);			PlotCIcon(&creatureRect1,creature1);			PlotCIcon(&creatureRect2,creature2);		DisposeCIcon(creature1);		DisposeCIcon(creature2);		creature1=GetCIcon(186);		creature2=GetCIcon(187);PauseAnim();	PauseAnim();						PlotCIcon(&creatureRect1,creature1);			PlotCIcon(&creatureRect2,creature2);		DisposeCIcon(creature1);		DisposeCIcon(creature2);PauseAnim();	PauseAnim();				}													}else if (GameCreatures[0].type==5)		/* blob */{for (x=0;x<=1;x++)	{		SetRect(&creatureRect1,146,120,210,184);		SetRect(&creatureRect2,146,184,210,248);			creature1=GetCIcon(165);			creature2=GetCIcon(166);			PlotCIcon(&creatureRect1,creature1);			PlotCIcon(&creatureRect2,creature2);		DisposeCIcon(creature1);		DisposeCIcon(creature2);			creature1=GetCIcon(167);			creature2=GetCIcon(168);PauseAnim();	PauseAnim();							PlotCIcon(&creatureRect1,creature1);			PlotCIcon(&creatureRect2,creature2);		DisposeCIcon(creature1);		DisposeCIcon(creature2);PauseAnim();	PauseAnim();				}										}else if (GameCreatures[0].type==1)		/* undead */{	creature1=GetCIcon(144);	creature2=GetCIcon(145);		SetRect(&creatureRect1,146,120,210,184);		SetRect(&creatureRect2,146,184,210,248);			PlotCIcon(&creatureRect1,creature1);						PlotCIcon(&creatureRect2,creature2);				DisposeCIcon(creature1);							DisposeCIcon(creature2);					creature1=GetCIcon(129);PauseAnim();	PauseAnim();					PlotCIcon(&creatureRect1,creature1);		DisposeCIcon(creature1);			Pause();		creature1=GetCIcon(144);PauseAnim();	PauseAnim();					PlotCIcon(&creatureRect1,creature1);		DisposeCIcon(creature1);			creature1=GetCIcon(129);PauseAnim();	PauseAnim();				PlotCIcon(&creatureRect1,creature1);		DisposeCIcon(creature1);		creature1=GetCIcon(144);	PauseAnim();	PauseAnim();			PlotCIcon(&creatureRect1,creature1);		DisposeCIcon(creature1);PauseAnim();	PauseAnim();											}else if (GameCreatures[0].type==3)		/* dragon */{for (x=0;x<=1;x++)	{	SetRect(&creatureRect1,120,96,184,160);	SetRect(&creatureRect2,184,96,248,160);	SetRect(&creatureRect3,248,96,312,160);		SetRect(&creatureRect4,120,160,184,224);	SetRect(&creatureRect5,184,160,248,224);	SetRect(&creatureRect6,248,160,312,224);		creature1=GetCIcon(159);		creature2=GetCIcon(161);		creature3=GetCIcon(163);		creature4=GetCIcon(160);		creature5=GetCIcon(162);		creature6=GetCIcon(164);				 				PlotCIcon(&creatureRect1,creature1);			PlotCIcon(&creatureRect2,creature2);		 	PlotCIcon(&creatureRect3,creature3);			PlotCIcon(&creatureRect4,creature4);			PlotCIcon(&creatureRect5,creature5);		 	PlotCIcon(&creatureRect6,creature6); 	DisposeCIcon(creature1);	DisposeCIcon(creature2);	DisposeCIcon(creature3);	DisposeCIcon(creature4);	DisposeCIcon(creature5);	DisposeCIcon(creature6);			creature1=GetCIcon(133);		creature4=GetCIcon(134);PauseAnim();	PauseAnim();				PlotCIcon(&creatureRect1,creature1);	PlotCIcon(&creatureRect4,creature4);DisposeCIcon(creature1);DisposeCIcon(creature4);	PauseAnim();	PauseAnim();	}								 			 	  		}else if (GameCreatures[0].type==2)		/* insect */{	creature1=GetCIcon(141);	creature2=GetCIcon(142);			SetRect(&creatureRect1,120,160,184,224);		SetRect(&creatureRect2,184,160,248,224);			PlotCIcon(&creatureRect1,creature1);			PlotCIcon(&creatureRect2,creature2);				DisposeCIcon(creature1);				DisposeCIcon(creature2); 			PauseAnim();PauseAnim();PauseAnim();				creature1=GetCIcon(143);					PlotCIcon(&creatureRect1,creature1);					DisposeCIcon(creature1);						creature2=GetCIcon(171);PauseAnim();PauseAnim();PauseAnim();								PlotCIcon(&creatureRect2,creature2);				DisposeCIcon(creature2); 			creature1=GetCIcon(141);		creature2=GetCIcon(142);PauseAnim();PauseAnim();PauseAnim();			PlotCIcon(&creatureRect1,creature1);	PlotCIcon(&creatureRect2,creature2);		DisposeCIcon(creature1);		DisposeCIcon(creature2);  					}else if (GameCreatures[0].type==6)		/* gaseous */{for (x=0;x<=1;x++)	{		SetRect(&creatureRect1,120,120,184,184);		SetRect(&creatureRect2,184,120,248,184);		SetRect(&creatureRect3,120,184,184,248);		SetRect(&creatureRect4,184,184,248,248);	creature1=GetCIcon(150);	creature2=GetCIcon(151);	creature3=GetCIcon(152);	creature4=GetCIcon(153);					  				PlotCIcon(&creatureRect1,creature1);			PlotCIcon(&creatureRect2,creature2);		 	PlotCIcon(&creatureRect3,creature3);  		 	PlotCIcon(&creatureRect4,creature4);		DisposeCIcon(creature1);		DisposeCIcon(creature2);		DisposeCIcon(creature3);		DisposeCIcon(creature4);	creature1=GetCIcon(182);	creature2=GetCIcon(183);	creature3=GetCIcon(184);	creature4=GetCIcon(185);PauseAnim();PauseAnim();PauseAnim();					PlotCIcon(&creatureRect1,creature1);			PlotCIcon(&creatureRect2,creature2);		 	PlotCIcon(&creatureRect3,creature3);  		 	PlotCIcon(&creatureRect4,creature4);		DisposeCIcon(creature1);		DisposeCIcon(creature2);		DisposeCIcon(creature3);		DisposeCIcon(creature4);PauseAnim();PauseAnim();PauseAnim();				}		 								 	}else if (GameCreatures[0].type==8)		/* animal */{  for (x=0;x<=1;x++)  	{		SetRect(&creatureRect1,120,120,184,184);		SetRect(&creatureRect2,184,120,248,184);		SetRect(&creatureRect3,120,184,184,248);		SetRect(&creatureRect4,184,184,248,248);  				creature1=GetCIcon(146);			creature2=GetCIcon(147);			creature3=GetCIcon(149);			creature4=GetCIcon(148);					  					PlotCIcon(&creatureRect1,creature1);				PlotCIcon(&creatureRect2,creature2);		 		PlotCIcon(&creatureRect3,creature3);  		 		PlotCIcon(&creatureRect4,creature4);			DisposeCIcon(creature1);			DisposeCIcon(creature2);			DisposeCIcon(creature3);			DisposeCIcon(creature4);		creature2=GetCIcon(180);		creature4=GetCIcon(179);PauseAnim();PauseAnim();PauseAnim();								PlotCIcon(&creatureRect2,creature2);  			PlotCIcon(&creatureRect4,creature4);		DisposeCIcon(creature2);		DisposeCIcon(creature4);PauseAnim();PauseAnim();PauseAnim();				}}}/****************************** CreatureDeath2 **************************************/CreatureDeath2(){PicHandle		creat1Pic1;									/* only one explosion */Rect			destRect,sourceRect,SightRect,bloodRect;	/* Temporary rect used for the pict & gworld. */ CGrafPtr		currentPort,currentPort2,currentPort3;		/* Port used before switching to the gworld's. */GDHandle		currentDevice,currentDevice2,currentDevice3;/* GDevice used before switching to the gworld's. */GWorldPtr		TempGWorld,TempGWorld2,TempGWorld3;			/* Pointer to Gworld */PixMapHandle	TempPixMap,TempPixMap2,TempPixMap3;			/* Needed PixMapHandle to lock down.*/		int				x,z,y,yy;		unsigned		min,max;/***  FIRST GWORLD -- used for dungeon screen ***/		RGBForeColor(white);	RGBBackColor(black);SetRect(&destRect,0,0,330,265);						/* SIZE of gworld rect */SetRect(&sourceRect,0,0,330,265);		NewGWorld( &TempGWorld, 0, &destRect, nil , nil, 0 );	TempPixMap = GetGWorldPixMap( TempGWorld );		/*  Get the GWorlds Pixmaphandle */		LockPixels( TempPixMap );					/*  Lock it down */		GetGWorld( &currentPort, &currentDevice );	/*  Save screen environment	*/		SetGWorld( TempGWorld, nil );				/*	Make screen GWorld current	*/						/*  make sure Fore ground color black */CopyBits ( &(*gGameWindow).portBits, 	  			/* copy screen to gworld */&(((GrafPtr) TempGWorld)->portBits), &sourceRect, &destRect, 0, nil ); 	/*** SECOND GWORLD -- used for creature ***/  RGBForeColor(white);RGBBackColor(black);	GetGWorld( &currentPort2, &currentDevice2 );	/*  Save screen environment	*/				SetRect(&destRect,0,0,128,128);				/* size of gworld */	NewGWorld( &TempGWorld2, 0, &destRect, nil , nil, 0 );TempPixMap2 = GetGWorldPixMap( TempGWorld2 );		/*  Get the GWorlds Pixmaphandle */LockPixels( TempPixMap2 );							/*  Lock it down */	/*** AFTER COPYING MAIN SCREEN AND SETTING UP 2nd GWORLD, GO GET CREATURE ***/	/* now get big explosion pics */	creat1Pic1=GetPicture(703);	/* get creature pict */		gSndNum=30725;				/* deader sound *//*** DRAW BIG EXPLOSION PICs ***/	SetGWorld( TempGWorld2, nil );				/* draw creature from resource */						/*  make sure Fore ground color black */	SetRect(&sourceRect,0,0,64,64);			/* gWorld creature coords*/		DrawPicture (creat1Pic1,&sourceRect);		/* creature drawn into gworld */PlaySound();for (x=1;x<=5;x++)								/* animation loop */{SetRect(&destRect,0,0,330,265);					/* SCREEN COORDS */SetRect(&sourceRect,0,0,330,265);				/* gWorld screen coords*/	SetGWorld( TempGWorld, nil );				// copy fresh screen from gworld		RGBForeColor(white);		RGBBackColor(black);	CopyBits (&(((GrafPtr) GlobalGWorld)->portBits), /* screen copy */		&(((GrafPtr) TempGWorld)->portBits), &sourceRect, &destRect,0, nil );SetRect(&destRect,181-(64*x),147-(64*x),181+(64*x),147+(64*x));		/* CREATURE gworld COORDS */SetRect(&sourceRect,0,0,64,64);				/* gWorld creature coords*/	SetGWorld( TempGWorld, nil );				// set to gworld2 for creature		RGBForeColor(white);		RGBBackColor(black);	CopyBits (&(((GrafPtr) TempGWorld2)->portBits), /* transparent creature copy */		&(((GrafPtr) TempGWorld)->portBits), &sourceRect, &destRect,36, nil );/** NOW GO TO MAIN screen and copy everything to it FROM gWorld! **/SetGWorld( currentPort, currentDevice );	/* now set back to screen */	SetPort(gGameWindow);					/* redundant call but..... */			SetRect(&destRect,33,33,330,265);		/* screen rect coords */	SetRect(&sourceRect,33,33,330,265);		/* gWorld screen coords*/		RGBForeColor(white);		RGBBackColor(black);			CopyBits (&(((GrafPtr) TempGWorld)->portBits), 	/* copy new scene to screen */	&(*gGameWindow).portBits, &sourceRect, &destRect,0, nil );}Pause();/** Go to MAIN screen and copy everything to it FROM gWorld! **/SetGWorld( currentPort, currentDevice );	/* now set back to screen */	SetPort(gGameWindow);					/* redundant call but..... */			SetRect(&destRect,33,33,330,265);		/* screen rect coords */	SetRect(&sourceRect,33,33,330,265);		/* gWorld screen coords*/		RGBForeColor(white);		RGBBackColor(black);			CopyBits (&(((GrafPtr) GlobalGWorld)->portBits), 	/* copy new scene to screen */	&(*gGameWindow).portBits, &sourceRect, &destRect,0, nil );DisposeGWorld(TempGWorld);				/* temp GWorld so get memory back */	 DisposeGWorld(TempGWorld2);			/* temp GWorld so get memory back */ReleaseResource(creat1Pic1);		/* free up memory */}/********************** GetCreature ******************************/GetCreature(theCreature)int				theCreature;{		SFReply		reply;	Point		myPoint;	SFTypeList	typeList;	int			numTypes;	int			z,dferror;	long		count;	short		rc,fRefNum;			myPoint.h	=100;	myPoint.v	= 100;	typeList[0] = 'RJG1';	numTypes	= 1;		rc=FSOpen("\pGBCreatures",0,&fRefNum);				/*** CREATURES ***/		dferror=2;										/* Dungeon datafile */ 	if (rc)												/* if ERROR */		DBErrors(dferror);								/* EXIT */				count = (sizeof(struct CreatureInfo));			/* only read 1 */		SetFPos ( fRefNum, 1, (count*theCreature));		/* set rec # */	 	FSRead ( fRefNum, &count, ((Ptr)GameCreatures));		FSClose (fRefNum);	fRefNum=0;			/* set to invalid # to avoid disk wipe-outs! */		}/********************** CheckForTreasure ******************************/CheckForTreasure()		/** gold for live chars only! **/{int				x,y,z,gold,count=0;unsigned		min,max;Str255			theText;if (gTreasure==YES)								/** if a chest is present already, leave */	return;	x=GetRandomNum(min=0,max=100);					/** GOLD **/	if (x<=85)									/** 85% chance of gold **/	{		Pause();		ClearMessage();			gold=GetRandomNum(min=4,max=75);				gold=gold*(gLevelCount+1);		/** gold is in relation to dung. level */					NumToString(gold,theText);					DrawString("\pYou found ");				DrawString(theText);			DrawString("\p gold pieces!");		Pause();	 	for (z=0;z<=gPartyNum;z++)	 		{	 			if (GameChars[gDungParty[z]].status >=2 && 	 				GameChars[gDungParty[z]].status <99)	 					count++;	 		}	 	gold=gold/count;		 	for (z=0;z<=gPartyNum;z++)	/** give gold to live chars only **/	 		{	 			if (GameChars[gDungParty[z]].status >=2 && 	 				GameChars[gDungParty[z]].status < 99)	 				{	 				if (GameChars[gDungParty[z]].gold+gold<=32000)	 					{	 					GameChars[gDungParty[z]].gold=	 					GameChars[gDungParty[z]].gold+gold;	 					}	 				else	 					GameChars[gDungParty[z]].gold=32000;	 				}	 		}	  }	  x=GetRandomNum(min=0,max=100);						/** TREASURE **/if (x<=75 && gLevelCount>=1)								/* on levels 2 or down */	{		ClearMessage();		DrawString("\pYou found a Present!");		gTreasure=YES;			}	}/********************** PlotChest ******************************/PlotChest()		 {if (gTreasure == YES){	if (gLevelCount>0 && gLevelCount<=6)	/** chests on lvl 2 and higher **/	{		gChestIcon=GetCIcon(135);		/* chest for lower levels */							PlotCIcon(&gChestRect,gChestIcon);		DisposeCIcon(gChestIcon);			  	}	else if (gLevelCount>=7 && gLevelCount<=13)	/** chests on lvl 7 and higher **/	{		gChestIcon=GetCIcon(139);							PlotCIcon(&gChestRect,gChestIcon);		DisposeCIcon(gChestIcon);  	} 	  }}/********************** TreasureRoutines ******************************/TreasureRoutines()		/** control routine for chests/treasures **/{int			x;Point		mouseLoc;GetMouse(&mouseLoc);	if (PtInRect(mouseLoc, &gChestRect) && gTreasure==YES)	/* treasure chest found */		{		Chest();		return;		}for (x=0;x<=2;x++)		/* click on found item?? if so, do it */		{			SetRect(&gItemRect,135+(x+1)*20,240,151+(x+1)*20,256);				LocalToGlobal(&gItemRect.top);				LocalToGlobal(&gItemRect.bottom);				if (PtInRect(gTheEvent.where, &gItemRect) && 				gFoundItems[x] != -1)				{				DragTreasure(x,gItemRect);					}			}	}								/********************** Chest ******************************/Chest()		 {int				x,y,z,itemNo,gold,count=0;unsigned		min,max;Str255			theText;Rect			gChestRect2;CIconHandle		gChestIcon2;gTreasure=NO;if (TrappedChest()==YES)		/* go check if chest is trapped */	return;	if (gLevelCount>0 && gLevelCount<=6)		{		SetRect(&gChestRect2,170,220,202,252);			 			gChestIcon2=GetCIcon(136);	}else if (gLevelCount>=7 && gLevelCount<=13)	{		SetRect(&gChestRect2,170,220,202,252);			 			gChestIcon2=GetCIcon(140);	}			ClearMessage();	DrawString("\pThe Present pops open!");	UpdateDV();						/** get rid of opened chest now **/			PlotCIcon(&gChestRect2,gChestIcon2);			DisposeCIcon(gChestIcon2);					Pause();			UpdateDV();						/** get rid of opened chest now **/		ClearMessage();if (GetRandomNum(min=0,max=100)<=35)	{	gSndNum=19402;		PlaySound();		ClearMessage();			gold=GetRandomNum(min=35,max=200);				gold=gold*gLevelCount;		/** gold is in relation to dung. level */					NumToString(gold,theText);					DrawString("\pYou found jewels worth ");				DrawString(theText);			DrawString("\p gold pieces!");		Pause();	 	for (z=0;z<=gPartyNum;z++)	 		{	 			if (GameChars[gDungParty[z]].status >=2 && 	 				GameChars[gDungParty[z]].status <99)	 					count++;	 		}	 	gold=gold/count;		 	for (z=0;z<=gPartyNum;z++)	/** give gold to live chars only **/	 		{	 			if (GameChars[gDungParty[z]].status >=2 && 	 				GameChars[gDungParty[z]].status < 99)	 				{	 				if (GameChars[gDungParty[z]].gold+gold<=32000)	 					{	 					GameChars[gDungParty[z]].gold=	 					GameChars[gDungParty[z]].gold+gold;	 					}	 				else	 					GameChars[gDungParty[z]].gold=32000;	 				}	 		}	  }	else  {	for (itemNo=0;itemNo<=2;itemNo++)	{	y=GetRandomNum(min=0,max=100);		/** any items inside?? **/		if (y<=55)						/** YES!  **/			ItemFound(itemNo);			/** Check for found items... Go plot items **/	}  }}/********************** TrappedChest ******************************/TrappedChest()		 {int				x,y,z,itemNo,theChar,count=0;unsigned		min,max;Str255			theText;Rect			ChestRect;CIconHandle		ChestIcon;z=GetRandomNum(min=0,max=100);	/* get random number */	if (z>=55+gLevelCount*2)	/* deeper you go, more chance of traps */		return(NO);				/* if not trapped, return for goodies */if (gDisarmSpellCast==YES)		/* if spell was cast, then return */	{	gDisarmSpellCast=NO;		/* reset spell though */	return(NO);	}	SetRect(&ChestRect,170,220,202,252);	/* set rect if trapped present */		ChestIcon=GetCIcon(205);		   z=GetRandomNum(min=0,max=4);switch(z)	{	case 0:		PlotCIcon(&ChestRect,ChestIcon);		UpdateDV();					/* replot dungeon */		ClearMessage();										gSndNum=30725;		PlaySound();		DrawString("\pThe Present explodes!");		break;	case 1:		PlotCIcon(&ChestRect,ChestIcon);		UpdateDV();					/* replot dungeon */		ClearMessage();															DrawString("\pPoisoned spikes shoot from the Present!");		gSndNum=16878;		PlaySound();		theChar=GetRandomNum(min=0,max=gPartyNum+1);				/* random char hit */		if (GameChars[gDungParty[theChar]].status >= 2 && 			GameChars[gDungParty[theChar]].status != 99 )			{				GameChars[gDungParty[theChar]].status=POISONED;				ClearMessage();					DrawString(GameChars[gDungParty[theChar]].name);					GameChars[gDungParty[theChar]].dmg++;						DrawString("\p has been poisoned!");				UpdateName(theChar);	/* update screen */				Pause();			}		break;			case 2:		PlotCIcon(&ChestRect,ChestIcon);			UpdateDV();						/* replot dungeon */			ClearMessage();																										gSndNum=25631;					/* teleport sound */		PlaySound();		DrawString("\pYou've been teleported!");			gLevelCount=GetRandomNum(min=1,max=gLevelCount+3);				if (gLevelCount>=12)					gLevelCount=12;		/* don't teleport lower than level 13 */			ReadDungeon();					break;			case 3:		PlotCIcon(&ChestRect,ChestIcon);			UpdateDV();						/* replot dungeon */		ClearMessage();																												gSndNum=25631;					/*  sound */		PlaySound();		DrawString(GameChars[gDungParty[theChar]].name);		DrawString("\p has been morgified into a Queer!");		GameChars[gDungParty[theChar]].type=0;			ReplotChar();		break;		default:		UpdateDV();						/* replot dungeon */		ClearMessage();																												DrawString("\pThe present was empty.");			break;				}		DisposeCIcon(ChestIcon);			  return(YES);	}/********************** PlayCreatureSound ******************************/PlayCreatureSound()		/** creature sound effects **/{ if (GameCreatures[0].type==1)				/* UNDEAD (M. Jackson) */	 	gSndNum=23976;else if (GameCreatures[0].type==2)			/* INSECT (Murphy) */	 	gSndNum=5313;else if (GameCreatures[0].type==3)			/* DRAGON (Patrick Stewart) */	 	gSndNum=3472;		 		 	else if (GameCreatures[0].type==4)			/* HUMANOID (Terminator) */	 	gSndNum=29993;else if (GameCreatures[0].type==5)			/* GAS (Roseanne Barr) */	 	gSndNum=24699;	 	else if (GameCreatures[0].type==8)			/* ANIMAL (Kirk) */	 	gSndNum=32745;else if (GameCreatures[0].type==7)			/* Spell Caster (Madonna) */	 	gSndNum=9679;		 		else if (GameCreatures[0].type==6)			/* GASEOUS (D. Letterman) */	 	gSndNum=25525;	else if (GameCreatures[0].type==9)			/* Humanoid2 (Terminator) */	 	gSndNum=29993;else if (GameCreatures[0].type==11)			/* Defender (Kaylin) */	 	gSndNum=400;		 			 		 			 		 	 		 	else	return;		 	 	 				PlaySound();}/********************** ItemFound ******************************/ItemFound(itemNo)		/** plot items which have been found **/int				itemNo;{Rect			itemRect;int				z=FALSE, x, y, anItem;Str255			theText;unsigned		min,max;		if (gLevelCount==0)				/* no chests on level 1 */			return;				while (z!=TRUE)							/* items found loop */	{	anItem=GetRandomNum(min=1,max=74);		if (gLevelCount==1 && GameItems[anItem].level<=1 || 			GameItems[anItem].type==MAGICVIAL)			z=TRUE;						/* on level 2, items=NORMAL */		else if (gLevelCount==2 && GameItems[anItem].level<=3 || 			GameItems[anItem].type==MAGICVIAL)			z=TRUE;					 	/* on level 3, items = between 1 & 2 */		else if (gLevelCount==3 && GameItems[anItem].level<=4			&& GameItems[anItem].level>=3  || 			GameItems[anItem].type==MAGICVIAL)			z=TRUE;					 	/* on level 4,items=between 2 & 3  */			else if (gLevelCount==4 && GameItems[anItem].level<=5			&& GameItems[anItem].level>=4  || 			GameItems[anItem].type==MAGICVIAL)			z=TRUE;					 	/* on level 5,items=between 3 & 4  */					else if (gLevelCount==5 && GameItems[anItem].level<=6			&& GameItems[anItem].level>=5  || 			GameItems[anItem].type==MAGICVIAL)			z=TRUE;					 	/* on level 6,items=between 4 & 5  */					else if (gLevelCount==6 && GameItems[anItem].level<=7			&& GameItems[anItem].level>=6  || 			GameItems[anItem].type==MAGICVIAL)			z=TRUE;					 	/* on level 7,items=between 5 & 6  */			else if (gLevelCount==7 && GameItems[anItem].level<=8			&& GameItems[anItem].level>=7  || 			GameItems[anItem].type==MAGICVIAL)			z=TRUE;					 	/* on level 8,items=between 6 & 7  */					else if (gLevelCount==8 && GameItems[anItem].level<=9			&& GameItems[anItem].level>=8  || 			GameItems[anItem].type==MAGICVIAL)			z=TRUE;					 	/* on level 9,items=between 7 & 8  */		else if (gLevelCount==9 && GameItems[anItem].level<=10			&& GameItems[anItem].level>=9  || 			GameItems[anItem].type==MAGICVIAL)			z=TRUE;					 	/* on level 10,items=between 8 & 9  */			else if (gLevelCount==10 && GameItems[anItem].level<=11			&& GameItems[anItem].level>=10  || 			GameItems[anItem].type==MAGICVIAL)			z=TRUE;					 	/* on level 11,items=between 9 & 10  */					else if (gLevelCount==11 && GameItems[anItem].level<=12			&& GameItems[anItem].level>=11  || 			GameItems[anItem].type==MAGICVIAL)			z=TRUE;					 	/* on level 12,items=between 10 & 11  */			else if (gLevelCount==12 && GameItems[anItem].level<=13			&& GameItems[anItem].level>=12  || 			GameItems[anItem].type==MAGICVIAL)			z=TRUE;					 	/* on level 13,items=between 12 & 12  */			else if (gLevelCount==13 && GameItems[anItem].level==13)			z=TRUE;					 	/* on level 6,items=between 12 & 13  */																}				gFoundItems[itemNo]=anItem;	/* item rec# into gFoundItems */			gItemsOnFloor=YES;				ClearMessage();				DrawString("\pYou found a ");				gSndNum=19402;					PlaySound();								LocalToGlobal(&gItemRect.top);	/* note: there is always an item in slot */					LocalToGlobal(&gItemRect.bottom);				SetRect(&gItemRect,135+((itemNo+1)*20),240,151+((itemNo+1)*20),256);  					switch (GameItems[anItem].type)					{					case MAGICVIAL:			 						  DrawString("\pMagic Vial!");					  PlotCIcon(&gItemRect,gVialIcon);					break;										case SWORD:			 						  DrawString("\pNail set!");					  PlotCIcon(&gItemRect,gSwordIcon);					break;					case DAGGER:			 						  DrawString("\pcan of Mace!");					  PlotCIcon(&gItemRect,gDaggerIcon);					break;					case HELMET:			 						  DrawString("\pTiara!");					  PlotCIcon(&gItemRect,gHelmetIcon);					break;						case SHIELD:			 						  DrawString("\pCondom!");					  PlotCIcon(&gItemRect,gShieldIcon);					break;													case FLAIL:			 						  DrawString("\pBlo Dryer!");					  PlotCIcon(&gItemRect,gFlailIcon);					break;					case GAUNTLETS:			 						  DrawString("\pPurse!");					  PlotCIcon(&gItemRect,gGlovesIcon);					break;						case CLOAK:			 						  DrawString("\pApron!");					  PlotCIcon(&gItemRect,gCloakIcon);					break;					case TORCH:			 						  DrawString("\pLighter!");					  PlotCIcon(&gItemRect,gTorchIcon);					break;										case ARMOR:			 						  DrawString("\pL. Jacket!");					  PlotCIcon(&gItemRect,gArmorIcon);					break;					case RING:			 						  DrawString("\pRing!");					  PlotCIcon(&gItemRect,gRingIcon);					break;						case SPHERE:			 						  DrawString("\pSphere!");					  PlotCIcon(&gItemRect,gSphereIcon);					break;					case BURNEDITEM:			 						  DrawString("\puseless burnt item!");					  PlotCIcon(&gItemRect,gBurnedIcon);					break;					}																							Pause();Pause();		ClearMessage();}/************************ DragTreasure ****************************/DragTreasure(itemNum,itemRect)int		itemNum;Rect	itemRect;{RgnHandle		itemRgn;Point			thePoint,destPoint;int				z,x,receiver=8,slot,result;long			release;	thePoint=gTheEvent.where;	itemRgn=NewRgn();							RectRgn(itemRgn,&itemRect);		release=DragGrayRgn(itemRgn,thePoint,&gConsoleRect,&gConsoleRect,0,0);	destPoint.v=thePoint.v+HiWord(release);	destPoint.h=thePoint.h+LoWord(release);	if (PtInRect(destPoint, &gCharRect0))			/************ CHAR 0 ***********/	receiver=gDungParty[0];else if (PtInRect(destPoint, &gCharRect1))		/************ CHAR 1 ***********/	receiver=gDungParty[1];	else if (PtInRect(destPoint, &gCharRect2))		/************ CHAR 2 ***********/	receiver=gDungParty[2];	else if (PtInRect(destPoint, &gCharRect3))		/************ CHAR 3 ***********/	receiver=gDungParty[3];else	return;	  	if (GameChars[receiver].status==DEAD ||		GameChars[receiver].status==PERMDEAD)		{		ClearMessage();			DrawString(GameChars[receiver].name);			DrawString("\p can't receive items.");		return;		}	  		for (z=0;z<=6;z++)			{			if (GameChars[receiver].items[z]==OPENSLOT)				{				 	slot=z;				 	break;			/* slot found! */				 }				 		}			if (z == 7)				/* no slots open */				{					ClearMessage();			 		DrawString(GameChars[receiver].name);					DrawString("\p cannot carry more items!");			 		 					return;				}									/* add item to char! */	GameChars[receiver].items[slot]=gFoundItems[itemNum]; 			ClearMessage();		 		DrawString(GameChars[receiver].name);					DrawString("\p has received the ");					switch (GameItems[gFoundItems[itemNum]].type)					{				 	case MAGICVIAL:			 						  DrawString("\pMagic Vial.");					break; 									 	case SWORD:			 						  DrawString("\pNails.");					break;   					case DAGGER:			 						  DrawString("\pMace.");					break;					case SHIELD:			 						  DrawString("\pCondom.");					break;										case HELMET:			 						  DrawString("\pTiara.");					break;										case FLAIL:			 						  DrawString("\pBlo Dryer.");					break;					case GAUNTLETS:			 						  DrawString("\pPurse.");					break;						case CLOAK:			 						  DrawString("\pApron.");					break;					case TORCH:			 						  DrawString("\pLighter.");					break;										case ARMOR:			 						  DrawString("\pL. Jacket.");					break;					case RING:			 						  DrawString("\pRing.");					break;						case SPHERE:			 						  DrawString("\pSphere.");					break;					case BURNEDITEM:			 						  DrawString("\pburned item.");					break;					}			gFoundItems[itemNum]=-1;		/* no item there now */		UpdateDV();							/* now replot over old item **/ for (x=0;x<=2;x++) 	{ 	  if (gFoundItems[x] != -1) 	  { 	  	LocalToGlobal(&gItemRect.top);					LocalToGlobal(&gItemRect.bottom);				SetRect(&gItemRect,135+((x+1)*20),240,151+((x+1)*20),256); 		switch (GameItems[gFoundItems[x]].type)			{			case MAGICVIAL:			 				  PlotCIcon(&gItemRect,gSphereIcon);			break;						case SWORD:			 				  PlotCIcon(&gItemRect,gSwordIcon);			break;			case DAGGER:			 				  PlotCIcon(&gItemRect,gDaggerIcon);			break;			case HELMET:			 				  PlotCIcon(&gItemRect,gHelmetIcon);			break;						case FLAIL:			 				  PlotCIcon(&gItemRect,gFlailIcon);			break;			case GAUNTLETS:			 				  PlotCIcon(&gItemRect,gGlovesIcon);			break;			case CLOAK:			 				  PlotCIcon(&gItemRect,gCloakIcon);			break;							case SHIELD:			 				  PlotCIcon(&gItemRect,gShieldIcon);			break;			case TORCH:			 				  PlotCIcon(&gItemRect,gTorchIcon);			break;								case ARMOR:			 				  PlotCIcon(&gItemRect,gArmorIcon);			break;			case RING:			 				  PlotCIcon(&gItemRect,gRingIcon);			break;				case SPHERE:			 				  PlotCIcon(&gItemRect,gSphereIcon);			break;			case BURNEDITEM:			 				  PlotCIcon(&gItemRect,gBurnedIcon);			break;			}			}	}}