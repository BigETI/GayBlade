/*********************************                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /***********************************   GayBlade   Ver 1.0.0    ****     INTRODUCTION WINDOW      ****   Programmed by Ryan Best    ****   ©Copyright 1994, Ryan Best ************************************/ #include "Packages.h"#include "GB.h"#include "Sound.h"#include "stdlib.h"#include "stdio.h"#include "OSUtils.h"#include "QDOffscreen.h"	 #include "fade.h"#define 	NIL_POINTER			0L#define		BASE_RES_ID	400#define		MOVE_TO_FRONT		(WindowPtr)-1L#define 	MIN_SLEEP			0L#define 	NIL_MOUSE_REGION	0L#define		REMOVE_ALL_EVENTS	0extern	Boolean			gDone, gWNEImplemented;extern	EventRecord		gTheEvent;extern	WindowPtr		gBackgrndWindow,gIntroWindow;extern	int				gCPUSpeed, gSndNum,gDialogNum,gVar=0;extern	PicHandle		gIntroPic;extern	DialogPtr		gCastleDialog;extern	CTabHandle 	gFade,			// 'clut' to alter with fading functions					gOrig;			// 'clut' to hold a copy of originalextern	Handle		gTempH;			//  temporary handle to copy 'clut'/**************************  CHECK COLOR STUFF ***********************/Boolean IsColor()		/* checks availability of Color quickDraw/8 bit color */{SysEnvRec	MySystem;GDHandle	curDev;int			pixDepth;SysEnvirons(2,&MySystem);gCPUSpeed=-1;		/* init gCPUSpeed */if (MySystem.hasColorQD==FALSE)	{		ParamText("\pGayBlade cannot run without Color QuickDraw!",0,0,0);			NoteAlert(6000,NIL_POINTER);		ExitToShell();	}	if (MySystem.processor>=3 || MySystem.processor==0)		gCPUSpeed=2;  					/* check CPU type for animation speed */	/* slow animation down by two times for 68040 & unknown systems */		curDev=GetMainDevice (  );	/* curDev=GetDeviceList(); */pixDepth=GetPixelDepth(curDev);if (pixDepth !=8)	{		ParamText("\pSet your monitor to 256 colors to run GayBlade!",0,0,0);			NoteAlert(6000,NIL_POINTER);		ExitToShell();	}}/**************************  GetPixelDepth ****************************/GetPixelDepth(theDevice)GDHandle	theDevice;{	PixMapHandle	screenPMapH;	int				pixelDepth;		screenPMapH	= (**theDevice).gdPMap;	pixelDepth = (**screenPMapH).pixelSize;	return(pixelDepth);}/**************************  GameIntro ********************************/GameIntro(){long			thetime,secs;int				yy,xx,width, height, sWidth, sHeight,h,w,v;GDHandle		curDev;char			theChar;GrafPtr			oldPort;Rect			totalRect, r,mBarRect,screenRect,worldBounds,*boundsPtr;RgnHandle		mBarRgn;CIconHandle		blink,blink2;GWorldPtr		world;GWorldPtr		MakeGWorld();Boolean			done, gWNEImplemented,Stop_Now;EventRecord		gTheEvent;short			rsrcFileNum;GrafPtr			g;GDHandle		hGD;CTabHandle		hCTab;				long ticks; 		gSndNum=17096;					/* intro music */			PlaySound();		fade_screen(128, true); 	//¥Fades screen to blackRGBForeColor(white);RGBBackColor(black);FlushEvents (everyEvent, REMOVE_ALL_EVENTS);	/* remove key clicks */	blink=GetCIcon(1000);	blink2=GetCIcon(1001);		SetRect(&worldBounds,0,0,512,512);			world=MakeGWorld(&worldBounds);			/** creates black background size of current screen **/gBackgrndWindow=NewWindow(NIL_POINTER, &(screenBits.bounds),NIL_TITLE,	VISIBLE,plainDBox,MOVE_TO_FRONT, NO_GO_AWAY,NIL_REF_CON);FillRect(&(gBackgrndWindow->portRect),black);		SetPort(gBackgrndWindow);	done=FALSE;	gIntroWindow=GetNewCWindow(400,NIL_POINTER,MOVE_TO_FRONT);	 			SetRect(&mBarRect,screenBits.bounds.left,			screenBits.bounds.top,			screenBits.bounds.right,			screenBits.bounds.top+20);		mBarRgn=NewRgn();		RectRgn(mBarRgn,&mBarRect);		UnionRgn(gIntroWindow->visRgn,mBarRgn,gIntroWindow->visRgn);	DisposeRgn(mBarRgn);FillRect(&(gIntroWindow->portRect),black); 	gIntroPic = GetPicture(BASE_RES_ID);		/* Citadel of the Dead */	/* CENTERS WINDOW */		r=gIntroWindow->portRect;			width=r.right - r.left;	height=r.bottom - r.top;	sWidth=screenBits.bounds.right-screenBits.bounds.left;	sHeight=screenBits.bounds.bottom-screenBits.bounds.top;	h=screenBits.bounds.left + ((sWidth-width)/2);	v=screenBits.bounds.top + ((sHeight-height)/2)+10;	MoveWindow(gIntroWindow,h,v,FALSE);	SelectWindow(gIntroWindow);			fade_screen(20, false);		/* fade In */				SetWindowPic(gIntroWindow,gIntroPic);		ShowWindow(gIntroWindow);	SetPort(gIntroWindow);		secs=Time+3; 	FlushEvents (everyEvent, REMOVE_ALL_EVENTS);	/* remove key clicks */	while(done==FALSE){	if (Time==secs)		{		BreathFire(world,blink,blink2);		/* animate it */		secs=Time+2;				}	if (gWNEImplemented)		{		WaitNextEvent(everyEvent,&gTheEvent,MIN_SLEEP,NIL_MOUSE_REGION);		SndTask();		}	else		{		SystemTask();		SndTask();		GetNextEvent(everyEvent, &gTheEvent);		}		switch (gTheEvent.what)		{		case updateEvt:							 			GetPort(&oldPort);		 							SetPort((WindowPtr)gTheEvent.message);				BeginUpdate((WindowPtr)gTheEvent.message);				EndUpdate((WindowPtr)gTheEvent.message); 			SetPort(oldPort);				break;		case mouseDown:		 		done=TRUE;	 			/* AStopSnd (Stop_Now=TRUE); 	 controls snds playing */ 	 			DisposeGWorld(world);	 			DisposeCIcon(blink);				DisposeCIcon(blink2);			break;		}  }}/********************** BreathFire ***********************************/BreathFire(world,blink,blink2)CIconHandle	blink,blink2;GWorldPtr	world;{Rect			source,dest,blinkRect,windowRect,typeRect,destRect;OSErr			error;unsigned long	finalTick;PicHandle		introType,introType2;short			rsrcFileNum;RGBForeColor(white);RGBBackColor(black); 	gSndNum=17096;					/* intro music */		PlaySound();introType = GetPicture (500);		/* sparkle */	introType2 = GetPicture (501);	/*	SetRect(&source,150,130,214,194);		SetRect(&blinkRect,90,102,154,166);			SetRect(&destRect,0,0,512,512);			SetRect(&dest,210,210,274,274); 	CopyIntroBits(world,&destRect);		copy current screen */	gSndNum=10305;		/* ping */		PlaySound();										if (gVar==0)	{		SetRect(&typeRect,437,225,513,364);		DrawPicture (introType, &typeRect);		Pause();		DrawPicture (introType2, &typeRect);				gVar=99;	}else	{			SetRect(&typeRect,437,225,513,364);		DrawPicture (introType2, &typeRect);		gVar=0;	}										 					}/********************** MakeGWorld ***********************************/GWorldPtr	MakeGWorld(boundsPtr)Rect	*boundsPtr;{	GWorldPtr	newWorld;	RGBColor	rgbColor;	Rect		r;	QDErr		errorCode;	errorCode=NewGWorld(&newWorld,0,boundsPtr,NIL_POINTER,NIL_POINTER,0L);	if (errorCode != noErr)	{		ParamText("\pOut of Memory. Program must exit.","\p","\p","\p");		NoteAlert(6000,NIL_POINTER);		ExitToShell();	}		return(newWorld);}/********************** MakeGWorld2 ***********************************/GWorldPtr	MakeGWorld2(boundsPtr)Rect	*boundsPtr;{	GWorldPtr	newWorld;	RGBColor	rgbColor;	Rect		r;	QDErr		errorCode;	errorCode=NewGWorld(&newWorld,0,boundsPtr,NIL_POINTER,NIL_POINTER,0L);	if (errorCode != noErr)	{		ParamText("\pOut of Memory. Program must exit.","\p","\p","\p");		NoteAlert(6000,NIL_POINTER);		ExitToShell();	}		return(newWorld);}/********************** CopyWorldBits ***********************************/CopyWorldBits(world,destRectPtr)GWorldPtr		world;Rect			*destRectPtr;{	GDHandle	oldGD;	GWorldPtr	oldGW,newWorld;		LockPixels(world->portPixMap);		CopyBits(&world->portPixMap,&thePort->portBits,				&world->portRect,destRectPtr,srcCopy,0);	UnlockPixels(world->portPixMap);}	/********************** CopyIntroBits ***********************************/CopyIntroBits(world,destRectPtr)GWorldPtr		world;Rect			*destRectPtr;{GDHandle	oldGD;GWorldPtr	oldGW,newWorld;	   CopyBits(&thePort->portBits,&world->portPixMap,			&world->portRect,destRectPtr,srcCopy,0);}